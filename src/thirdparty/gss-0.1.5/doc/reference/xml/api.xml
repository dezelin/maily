<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="gss-api">
<refmeta>
<refentrytitle role="top_of_page" id="gss-api.top_of_page">api</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>
  GSS Library
</refmiscinfo>
</refmeta>
<refnamediv>
<refname>api</refname>
<refpurpose></refpurpose>
</refnamediv>

<refsynopsisdiv id="gss-api.synopsis" role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>typedef             <link linkend="gss-ctx-id-t">gss_ctx_id_t</link>;
typedef             <link linkend="gss-cred-id-t">gss_cred_id_t</link>;
typedef             <link linkend="gss-name-t">gss_name_t</link>;
typedef             <link linkend="gss-uint32">gss_uint32</link>;
typedef             <link linkend="OM-uint32">OM_uint32</link>;
typedef             <link linkend="gss-qop-t">gss_qop_t</link>;
typedef             <link linkend="gss-cred-usage-t">gss_cred_usage_t</link>;
#define             <link linkend="GSS-C-DELEG-FLAG:CAPS">GSS_C_DELEG_FLAG</link>
#define             <link linkend="GSS-C-MUTUAL-FLAG:CAPS">GSS_C_MUTUAL_FLAG</link>
#define             <link linkend="GSS-C-REPLAY-FLAG:CAPS">GSS_C_REPLAY_FLAG</link>
#define             <link linkend="GSS-C-SEQUENCE-FLAG:CAPS">GSS_C_SEQUENCE_FLAG</link>
#define             <link linkend="GSS-C-CONF-FLAG:CAPS">GSS_C_CONF_FLAG</link>
#define             <link linkend="GSS-C-INTEG-FLAG:CAPS">GSS_C_INTEG_FLAG</link>
#define             <link linkend="GSS-C-ANON-FLAG:CAPS">GSS_C_ANON_FLAG</link>
#define             <link linkend="GSS-C-PROT-READY-FLAG:CAPS">GSS_C_PROT_READY_FLAG</link>
#define             <link linkend="GSS-C-TRANS-FLAG:CAPS">GSS_C_TRANS_FLAG</link>
#define             <link linkend="GSS-C-BOTH:CAPS">GSS_C_BOTH</link>
#define             <link linkend="GSS-C-INITIATE:CAPS">GSS_C_INITIATE</link>
#define             <link linkend="GSS-C-ACCEPT:CAPS">GSS_C_ACCEPT</link>
#define             <link linkend="GSS-C-GSS-CODE:CAPS">GSS_C_GSS_CODE</link>
#define             <link linkend="GSS-C-MECH-CODE:CAPS">GSS_C_MECH_CODE</link>
#define             <link linkend="GSS-C-AF-UNSPEC:CAPS">GSS_C_AF_UNSPEC</link>
#define             <link linkend="GSS-C-AF-LOCAL:CAPS">GSS_C_AF_LOCAL</link>
#define             <link linkend="GSS-C-AF-INET:CAPS">GSS_C_AF_INET</link>
#define             <link linkend="GSS-C-AF-IMPLINK:CAPS">GSS_C_AF_IMPLINK</link>
#define             <link linkend="GSS-C-AF-PUP:CAPS">GSS_C_AF_PUP</link>
#define             <link linkend="GSS-C-AF-CHAOS:CAPS">GSS_C_AF_CHAOS</link>
#define             <link linkend="GSS-C-AF-NS:CAPS">GSS_C_AF_NS</link>
#define             <link linkend="GSS-C-AF-NBS:CAPS">GSS_C_AF_NBS</link>
#define             <link linkend="GSS-C-AF-ECMA:CAPS">GSS_C_AF_ECMA</link>
#define             <link linkend="GSS-C-AF-DATAKIT:CAPS">GSS_C_AF_DATAKIT</link>
#define             <link linkend="GSS-C-AF-CCITT:CAPS">GSS_C_AF_CCITT</link>
#define             <link linkend="GSS-C-AF-SNA:CAPS">GSS_C_AF_SNA</link>
#define             <link linkend="GSS-C-AF-DECnet">GSS_C_AF_DECnet</link>
#define             <link linkend="GSS-C-AF-DLI:CAPS">GSS_C_AF_DLI</link>
#define             <link linkend="GSS-C-AF-LAT:CAPS">GSS_C_AF_LAT</link>
#define             <link linkend="GSS-C-AF-HYLINK:CAPS">GSS_C_AF_HYLINK</link>
#define             <link linkend="GSS-C-AF-APPLETALK:CAPS">GSS_C_AF_APPLETALK</link>
#define             <link linkend="GSS-C-AF-BSC:CAPS">GSS_C_AF_BSC</link>
#define             <link linkend="GSS-C-AF-DSS:CAPS">GSS_C_AF_DSS</link>
#define             <link linkend="GSS-C-AF-OSI:CAPS">GSS_C_AF_OSI</link>
#define             <link linkend="GSS-C-AF-X25:CAPS">GSS_C_AF_X25</link>
#define             <link linkend="GSS-C-AF-NULLADDR:CAPS">GSS_C_AF_NULLADDR</link>
#define             <link linkend="GSS-C-NO-NAME:CAPS">GSS_C_NO_NAME</link>
#define             <link linkend="GSS-C-NO-BUFFER:CAPS">GSS_C_NO_BUFFER</link>
#define             <link linkend="GSS-C-NO-OID:CAPS">GSS_C_NO_OID</link>
#define             <link linkend="GSS-C-NO-OID-SET:CAPS">GSS_C_NO_OID_SET</link>
#define             <link linkend="GSS-C-NO-CONTEXT:CAPS">GSS_C_NO_CONTEXT</link>
#define             <link linkend="GSS-C-NO-CREDENTIAL:CAPS">GSS_C_NO_CREDENTIAL</link>
#define             <link linkend="GSS-C-NO-CHANNEL-BINDINGS:CAPS">GSS_C_NO_CHANNEL_BINDINGS</link>
#define             <link linkend="GSS-C-EMPTY-BUFFER:CAPS">GSS_C_EMPTY_BUFFER</link>
#define             <link linkend="GSS-C-NULL-OID:CAPS">GSS_C_NULL_OID</link>
#define             <link linkend="GSS-C-NULL-OID-SET:CAPS">GSS_C_NULL_OID_SET</link>
#define             <link linkend="GSS-C-QOP-DEFAULT:CAPS">GSS_C_QOP_DEFAULT</link>
#define             <link linkend="GSS-C-INDEFINITE:CAPS">GSS_C_INDEFINITE</link>
extern              gss_OID <link linkend="GSS-C-NT-USER-NAME:CAPS">GSS_C_NT_USER_NAME</link>;
extern              gss_OID <link linkend="GSS-C-NT-MACHINE-UID-NAME:CAPS">GSS_C_NT_MACHINE_UID_NAME</link>;
extern              gss_OID <link linkend="GSS-C-NT-STRING-UID-NAME:CAPS">GSS_C_NT_STRING_UID_NAME</link>;
extern              gss_OID <link linkend="GSS-C-NT-HOSTBASED-SERVICE-X:CAPS">GSS_C_NT_HOSTBASED_SERVICE_X</link>;
extern              gss_OID <link linkend="GSS-C-NT-HOSTBASED-SERVICE:CAPS">GSS_C_NT_HOSTBASED_SERVICE</link>;
extern              gss_OID <link linkend="GSS-C-NT-ANONYMOUS:CAPS">GSS_C_NT_ANONYMOUS</link>;
extern              gss_OID <link linkend="GSS-C-NT-EXPORT-NAME:CAPS">GSS_C_NT_EXPORT_NAME</link>;
#define             <link linkend="GSS-S-COMPLETE:CAPS">GSS_S_COMPLETE</link>
#define             <link linkend="GSS-C-CALLING-ERROR-OFFSET:CAPS">GSS_C_CALLING_ERROR_OFFSET</link>
#define             <link linkend="GSS-C-ROUTINE-ERROR-OFFSET:CAPS">GSS_C_ROUTINE_ERROR_OFFSET</link>
#define             <link linkend="GSS-C-SUPPLEMENTARY-OFFSET:CAPS">GSS_C_SUPPLEMENTARY_OFFSET</link>
#define             <link linkend="GSS-C-CALLING-ERROR-MASK:CAPS">GSS_C_CALLING_ERROR_MASK</link>
#define             <link linkend="GSS-C-ROUTINE-ERROR-MASK:CAPS">GSS_C_ROUTINE_ERROR_MASK</link>
#define             <link linkend="GSS-C-SUPPLEMENTARY-MASK:CAPS">GSS_C_SUPPLEMENTARY_MASK</link>
#define             <link linkend="GSS-CALLING-ERROR:CAPS">GSS_CALLING_ERROR</link>                   (x)
#define             <link linkend="GSS-ROUTINE-ERROR:CAPS">GSS_ROUTINE_ERROR</link>                   (x)
#define             <link linkend="GSS-SUPPLEMENTARY-INFO:CAPS">GSS_SUPPLEMENTARY_INFO</link>              (x)
#define             <link linkend="GSS-ERROR:CAPS">GSS_ERROR</link>                           (x)
#define             <link linkend="GSS-S-CALL-INACCESSIBLE-READ:CAPS">GSS_S_CALL_INACCESSIBLE_READ</link>
#define             <link linkend="GSS-S-CALL-INACCESSIBLE-WRITE:CAPS">GSS_S_CALL_INACCESSIBLE_WRITE</link>
#define             <link linkend="GSS-S-CALL-BAD-STRUCTURE:CAPS">GSS_S_CALL_BAD_STRUCTURE</link>
#define             <link linkend="GSS-S-BAD-MECH:CAPS">GSS_S_BAD_MECH</link>
#define             <link linkend="GSS-S-BAD-NAME:CAPS">GSS_S_BAD_NAME</link>
#define             <link linkend="GSS-S-BAD-NAMETYPE:CAPS">GSS_S_BAD_NAMETYPE</link>
#define             <link linkend="GSS-S-BAD-BINDINGS:CAPS">GSS_S_BAD_BINDINGS</link>
#define             <link linkend="GSS-S-BAD-STATUS:CAPS">GSS_S_BAD_STATUS</link>
#define             <link linkend="GSS-S-BAD-SIG:CAPS">GSS_S_BAD_SIG</link>
#define             <link linkend="GSS-S-BAD-MIC:CAPS">GSS_S_BAD_MIC</link>
#define             <link linkend="GSS-S-NO-CRED:CAPS">GSS_S_NO_CRED</link>
#define             <link linkend="GSS-S-NO-CONTEXT:CAPS">GSS_S_NO_CONTEXT</link>
#define             <link linkend="GSS-S-DEFECTIVE-TOKEN:CAPS">GSS_S_DEFECTIVE_TOKEN</link>
#define             <link linkend="GSS-S-DEFECTIVE-CREDENTIAL:CAPS">GSS_S_DEFECTIVE_CREDENTIAL</link>
#define             <link linkend="GSS-S-CREDENTIALS-EXPIRED:CAPS">GSS_S_CREDENTIALS_EXPIRED</link>
#define             <link linkend="GSS-S-CONTEXT-EXPIRED:CAPS">GSS_S_CONTEXT_EXPIRED</link>
#define             <link linkend="GSS-S-FAILURE:CAPS">GSS_S_FAILURE</link>
#define             <link linkend="GSS-S-BAD-QOP:CAPS">GSS_S_BAD_QOP</link>
#define             <link linkend="GSS-S-UNAUTHORIZED:CAPS">GSS_S_UNAUTHORIZED</link>
#define             <link linkend="GSS-S-UNAVAILABLE:CAPS">GSS_S_UNAVAILABLE</link>
#define             <link linkend="GSS-S-DUPLICATE-ELEMENT:CAPS">GSS_S_DUPLICATE_ELEMENT</link>
#define             <link linkend="GSS-S-NAME-NOT-MN:CAPS">GSS_S_NAME_NOT_MN</link>
#define             <link linkend="GSS-S-CONTINUE-NEEDED:CAPS">GSS_S_CONTINUE_NEEDED</link>
#define             <link linkend="GSS-S-DUPLICATE-TOKEN:CAPS">GSS_S_DUPLICATE_TOKEN</link>
#define             <link linkend="GSS-S-OLD-TOKEN:CAPS">GSS_S_OLD_TOKEN</link>
#define             <link linkend="GSS-S-UNSEQ-TOKEN:CAPS">GSS_S_UNSEQ_TOKEN</link>
#define             <link linkend="GSS-S-GAP-TOKEN:CAPS">GSS_S_GAP_TOKEN</link>
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-acquire-cred">gss_acquire_cred</link>                    (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> desired_name</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> time_req</parameter>,
                                                         <parameter>const <link linkend="gss-OID-set"><type>gss_OID_set</type></link> desired_mechs</parameter>,
                                                         <parameter><link linkend="gss-cred-usage-t"><type>gss_cred_usage_t</type></link> cred_usage</parameter>,
                                                         <parameter><link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> *output_cred_handle</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *actual_mechs</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *time_rec</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-release-cred">gss_release_cred</link>                    (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> *cred_handle</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-init-sec-context">gss_init_sec_context</link>                (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> initiator_cred_handle</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> *context_handle</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> target_name</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> mech_type</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> req_flags</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> time_req</parameter>,
                                                         <parameter>const <link linkend="gss-channel-bindings-t"><type>gss_channel_bindings_t</type></link> input_chan_bindings</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> input_token</parameter>,
                                                         <parameter><link linkend="gss-OID"><type>gss_OID</type></link> *actual_mech_type</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> output_token</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *ret_flags</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *time_rec</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-accept-sec-context">gss_accept_sec_context</link>              (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> *context_handle</parameter>,
                                                         <parameter>const <link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> acceptor_cred_handle</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> input_token_buffer</parameter>,
                                                         <parameter>const <link linkend="gss-channel-bindings-t"><type>gss_channel_bindings_t</type></link> input_chan_bindings</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *src_name</parameter>,
                                                         <parameter><link linkend="gss-OID"><type>gss_OID</type></link> *mech_type</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> output_token</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *ret_flags</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *time_rec</parameter>,
                                                         <parameter><link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> *delegated_cred_handle</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-process-context-token">gss_process_context_token</link>           (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> token_buffer</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-delete-sec-context">gss_delete_sec_context</link>              (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> *context_handle</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> output_token</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-context-time">gss_context_time</link>                    (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *time_rec</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-get-mic">gss_get_mic</link>                         (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="gss-qop-t"><type>gss_qop_t</type></link> qop_req</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> message_buffer</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> message_token</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-verify-mic">gss_verify_mic</link>                      (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> message_buffer</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> token_buffer</parameter>,
                                                         <parameter><link linkend="gss-qop-t"><type>gss_qop_t</type></link> *qop_state</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-wrap">gss_wrap</link>                            (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> conf_req_flag</parameter>,
                                                         <parameter><link linkend="gss-qop-t"><type>gss_qop_t</type></link> qop_req</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> input_message_buffer</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *conf_state</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> output_message_buffer</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-unwrap">gss_unwrap</link>                          (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> input_message_buffer</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> output_message_buffer</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *conf_state</parameter>,
                                                         <parameter><link linkend="gss-qop-t"><type>gss_qop_t</type></link> *qop_state</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-display-status">gss_display_status</link>                  (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> status_value</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> status_type</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> mech_type</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *message_context</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> status_string</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-indicate-mechs">gss_indicate_mechs</link>                  (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *mech_set</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-compare-name">gss_compare_name</link>                    (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> name1</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> name2</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *name_equal</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-display-name">gss_display_name</link>                    (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> input_name</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> output_name_buffer</parameter>,
                                                         <parameter><link linkend="gss-OID"><type>gss_OID</type></link> *output_name_type</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-import-name">gss_import_name</link>                     (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> input_name_buffer</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> input_name_type</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *output_name</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-export-name">gss_export_name</link>                     (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> input_name</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> exported_name</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-release-name">gss_release_name</link>                    (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *name</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-release-buffer">gss_release_buffer</link>                  (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> buffer</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-release-oid-set">gss_release_oid_set</link>                 (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *set</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-inquire-cred">gss_inquire_cred</link>                    (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> cred_handle</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *name</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *lifetime</parameter>,
                                                         <parameter><link linkend="gss-cred-usage-t"><type>gss_cred_usage_t</type></link> *cred_usage</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *mechanisms</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-inquire-context">gss_inquire_context</link>                 (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *src_name</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *targ_name</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *lifetime_rec</parameter>,
                                                         <parameter><link linkend="gss-OID"><type>gss_OID</type></link> *mech_type</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *ctx_flags</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *locally_initiated</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *open</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-wrap-size-limit">gss_wrap_size_limit</link>                 (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> conf_req_flag</parameter>,
                                                         <parameter><link linkend="gss-qop-t"><type>gss_qop_t</type></link> qop_req</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> req_output_size</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *max_input_size</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-add-cred">gss_add_cred</link>                        (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> input_cred_handle</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> desired_name</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> desired_mech</parameter>,
                                                         <parameter><link linkend="gss-cred-usage-t"><type>gss_cred_usage_t</type></link> cred_usage</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> initiator_time_req</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> acceptor_time_req</parameter>,
                                                         <parameter><link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> *output_cred_handle</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *actual_mechs</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *initiator_time_rec</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *acceptor_time_rec</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-inquire-cred-by-mech">gss_inquire_cred_by_mech</link>            (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> cred_handle</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> mech_type</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *name</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *initiator_lifetime</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *acceptor_lifetime</parameter>,
                                                         <parameter><link linkend="gss-cred-usage-t"><type>gss_cred_usage_t</type></link> *cred_usage</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-export-sec-context">gss_export_sec_context</link>              (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> *context_handle</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> interprocess_token</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-import-sec-context">gss_import_sec_context</link>              (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> interprocess_token</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> *context_handle</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-create-empty-oid-set">gss_create_empty_oid_set</link>            (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *oid_set</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-add-oid-set-member">gss_add_oid_set_member</link>              (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> member_oid</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *oid_set</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-test-oid-set-member">gss_test_oid_set_member</link>             (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> member</parameter>,
                                                         <parameter>const <link linkend="gss-OID-set"><type>gss_OID_set</type></link> set</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *present</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-inquire-names-for-mech">gss_inquire_names_for_mech</link>          (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> mechanism</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *name_types</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-inquire-mechs-for-name">gss_inquire_mechs_for_name</link>          (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> input_name</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *mech_types</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-canonicalize-name">gss_canonicalize_name</link>               (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> input_name</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> mech_type</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *output_name</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-duplicate-name">gss_duplicate_name</link>                  (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> src_name</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *dest_name</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-sign">gss_sign</link>                            (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> qop_req</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> message_buffer</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> message_token</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-verify">gss_verify</link>                          (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> message_buffer</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> token_buffer</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *qop_state</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-seal">gss_seal</link>                            (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> conf_req_flag</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> qop_req</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> input_message_buffer</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *conf_state</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> output_message_buffer</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-unseal">gss_unseal</link>                          (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> input_message_buffer</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> output_message_buffer</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *conf_state</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *qop_state</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-inquire-saslname-for-mech">gss_inquire_saslname_for_mech</link>       (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> desired_mech</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> sasl_mech_name</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> mech_name</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> mech_description</parameter>);
<link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           <link linkend="gss-inquire-mech-for-saslname">gss_inquire_mech_for_saslname</link>       (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> sasl_mech_name</parameter>,
                                                         <parameter><link linkend="gss-OID"><type>gss_OID</type></link> *mech_type</parameter>);
</synopsis>
</refsynopsisdiv>

<refsect1 id="gss-api.description" role="desc">
<title role="desc.title">Description</title>
<para>
</para>
</refsect1>
<refsect1 id="gss-api.details" role="details">
<title role="details.title">Details</title>
<refsect2 id="gss-ctx-id-t" role="typedef">
<title>gss_ctx_id_t</title>
<indexterm zone="gss-ctx-id-t"><primary>gss_ctx_id_t</primary></indexterm>
<programlisting>typedef struct gss_ctx_id_struct *gss_ctx_id_t;
</programlisting>
<para>
</para></refsect2>
<refsect2 id="gss-cred-id-t" role="typedef">
<title>gss_cred_id_t</title>
<indexterm zone="gss-cred-id-t"><primary>gss_cred_id_t</primary></indexterm>
<programlisting>typedef struct gss_cred_id_struct *gss_cred_id_t;
</programlisting>
<para>
</para></refsect2>
<refsect2 id="gss-name-t" role="typedef">
<title>gss_name_t</title>
<indexterm zone="gss-name-t"><primary>gss_name_t</primary></indexterm>
<programlisting>typedef struct gss_name_struct *gss_name_t;
</programlisting>
<para>
</para></refsect2>
<refsect2 id="gss-uint32" role="typedef">
<title>gss_uint32</title>
<indexterm zone="gss-uint32"><primary>gss_uint32</primary></indexterm>
<para>
</para></refsect2>
<refsect2 id="OM-uint32" role="typedef">
<title>OM_uint32</title>
<indexterm zone="OM-uint32"><primary>OM_uint32</primary></indexterm>
<programlisting>typedef gss_uint32 OM_uint32;
</programlisting>
<para>
</para></refsect2>
<refsect2 id="gss-qop-t" role="typedef">
<title>gss_qop_t</title>
<indexterm zone="gss-qop-t"><primary>gss_qop_t</primary></indexterm>
<programlisting>typedef OM_uint32 gss_qop_t;
</programlisting>
<para>
</para></refsect2>
<refsect2 id="gss-cred-usage-t" role="typedef">
<title>gss_cred_usage_t</title>
<indexterm zone="gss-cred-usage-t"><primary>gss_cred_usage_t</primary></indexterm>
<programlisting>typedef int gss_cred_usage_t;
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-DELEG-FLAG:CAPS" role="macro">
<title>GSS_C_DELEG_FLAG</title>
<indexterm zone="GSS-C-DELEG-FLAG:CAPS"><primary>GSS_C_DELEG_FLAG</primary></indexterm>
<programlisting>#define GSS_C_DELEG_FLAG      1
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-MUTUAL-FLAG:CAPS" role="macro">
<title>GSS_C_MUTUAL_FLAG</title>
<indexterm zone="GSS-C-MUTUAL-FLAG:CAPS"><primary>GSS_C_MUTUAL_FLAG</primary></indexterm>
<programlisting>#define GSS_C_MUTUAL_FLAG     2
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-REPLAY-FLAG:CAPS" role="macro">
<title>GSS_C_REPLAY_FLAG</title>
<indexterm zone="GSS-C-REPLAY-FLAG:CAPS"><primary>GSS_C_REPLAY_FLAG</primary></indexterm>
<programlisting>#define GSS_C_REPLAY_FLAG     4
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-SEQUENCE-FLAG:CAPS" role="macro">
<title>GSS_C_SEQUENCE_FLAG</title>
<indexterm zone="GSS-C-SEQUENCE-FLAG:CAPS"><primary>GSS_C_SEQUENCE_FLAG</primary></indexterm>
<programlisting>#define GSS_C_SEQUENCE_FLAG   8
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-CONF-FLAG:CAPS" role="macro">
<title>GSS_C_CONF_FLAG</title>
<indexterm zone="GSS-C-CONF-FLAG:CAPS"><primary>GSS_C_CONF_FLAG</primary></indexterm>
<programlisting>#define GSS_C_CONF_FLAG       16
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-INTEG-FLAG:CAPS" role="macro">
<title>GSS_C_INTEG_FLAG</title>
<indexterm zone="GSS-C-INTEG-FLAG:CAPS"><primary>GSS_C_INTEG_FLAG</primary></indexterm>
<programlisting>#define GSS_C_INTEG_FLAG      32
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-ANON-FLAG:CAPS" role="macro">
<title>GSS_C_ANON_FLAG</title>
<indexterm zone="GSS-C-ANON-FLAG:CAPS"><primary>GSS_C_ANON_FLAG</primary></indexterm>
<programlisting>#define GSS_C_ANON_FLAG       64
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-PROT-READY-FLAG:CAPS" role="macro">
<title>GSS_C_PROT_READY_FLAG</title>
<indexterm zone="GSS-C-PROT-READY-FLAG:CAPS"><primary>GSS_C_PROT_READY_FLAG</primary></indexterm>
<programlisting>#define GSS_C_PROT_READY_FLAG 128
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-TRANS-FLAG:CAPS" role="macro">
<title>GSS_C_TRANS_FLAG</title>
<indexterm zone="GSS-C-TRANS-FLAG:CAPS"><primary>GSS_C_TRANS_FLAG</primary></indexterm>
<programlisting>#define GSS_C_TRANS_FLAG      256
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-BOTH:CAPS" role="macro">
<title>GSS_C_BOTH</title>
<indexterm zone="GSS-C-BOTH:CAPS"><primary>GSS_C_BOTH</primary></indexterm>
<programlisting>#define GSS_C_BOTH     0
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-INITIATE:CAPS" role="macro">
<title>GSS_C_INITIATE</title>
<indexterm zone="GSS-C-INITIATE:CAPS"><primary>GSS_C_INITIATE</primary></indexterm>
<programlisting>#define GSS_C_INITIATE 1
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-ACCEPT:CAPS" role="macro">
<title>GSS_C_ACCEPT</title>
<indexterm zone="GSS-C-ACCEPT:CAPS"><primary>GSS_C_ACCEPT</primary></indexterm>
<programlisting>#define GSS_C_ACCEPT   2
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-GSS-CODE:CAPS" role="macro">
<title>GSS_C_GSS_CODE</title>
<indexterm zone="GSS-C-GSS-CODE:CAPS"><primary>GSS_C_GSS_CODE</primary></indexterm>
<programlisting>#define GSS_C_GSS_CODE  1
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-MECH-CODE:CAPS" role="macro">
<title>GSS_C_MECH_CODE</title>
<indexterm zone="GSS-C-MECH-CODE:CAPS"><primary>GSS_C_MECH_CODE</primary></indexterm>
<programlisting>#define GSS_C_MECH_CODE 2
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-UNSPEC:CAPS" role="macro">
<title>GSS_C_AF_UNSPEC</title>
<indexterm zone="GSS-C-AF-UNSPEC:CAPS"><primary>GSS_C_AF_UNSPEC</primary></indexterm>
<programlisting>#define GSS_C_AF_UNSPEC     0
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-LOCAL:CAPS" role="macro">
<title>GSS_C_AF_LOCAL</title>
<indexterm zone="GSS-C-AF-LOCAL:CAPS"><primary>GSS_C_AF_LOCAL</primary></indexterm>
<programlisting>#define GSS_C_AF_LOCAL      1
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-INET:CAPS" role="macro">
<title>GSS_C_AF_INET</title>
<indexterm zone="GSS-C-AF-INET:CAPS"><primary>GSS_C_AF_INET</primary></indexterm>
<programlisting>#define GSS_C_AF_INET       2
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-IMPLINK:CAPS" role="macro">
<title>GSS_C_AF_IMPLINK</title>
<indexterm zone="GSS-C-AF-IMPLINK:CAPS"><primary>GSS_C_AF_IMPLINK</primary></indexterm>
<programlisting>#define GSS_C_AF_IMPLINK    3
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-PUP:CAPS" role="macro">
<title>GSS_C_AF_PUP</title>
<indexterm zone="GSS-C-AF-PUP:CAPS"><primary>GSS_C_AF_PUP</primary></indexterm>
<programlisting>#define GSS_C_AF_PUP        4
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-CHAOS:CAPS" role="macro">
<title>GSS_C_AF_CHAOS</title>
<indexterm zone="GSS-C-AF-CHAOS:CAPS"><primary>GSS_C_AF_CHAOS</primary></indexterm>
<programlisting>#define GSS_C_AF_CHAOS      5
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-NS:CAPS" role="macro">
<title>GSS_C_AF_NS</title>
<indexterm zone="GSS-C-AF-NS:CAPS"><primary>GSS_C_AF_NS</primary></indexterm>
<programlisting>#define GSS_C_AF_NS         6
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-NBS:CAPS" role="macro">
<title>GSS_C_AF_NBS</title>
<indexterm zone="GSS-C-AF-NBS:CAPS"><primary>GSS_C_AF_NBS</primary></indexterm>
<programlisting>#define GSS_C_AF_NBS        7
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-ECMA:CAPS" role="macro">
<title>GSS_C_AF_ECMA</title>
<indexterm zone="GSS-C-AF-ECMA:CAPS"><primary>GSS_C_AF_ECMA</primary></indexterm>
<programlisting>#define GSS_C_AF_ECMA       8
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-DATAKIT:CAPS" role="macro">
<title>GSS_C_AF_DATAKIT</title>
<indexterm zone="GSS-C-AF-DATAKIT:CAPS"><primary>GSS_C_AF_DATAKIT</primary></indexterm>
<programlisting>#define GSS_C_AF_DATAKIT    9
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-CCITT:CAPS" role="macro">
<title>GSS_C_AF_CCITT</title>
<indexterm zone="GSS-C-AF-CCITT:CAPS"><primary>GSS_C_AF_CCITT</primary></indexterm>
<programlisting>#define GSS_C_AF_CCITT      10
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-SNA:CAPS" role="macro">
<title>GSS_C_AF_SNA</title>
<indexterm zone="GSS-C-AF-SNA:CAPS"><primary>GSS_C_AF_SNA</primary></indexterm>
<programlisting>#define GSS_C_AF_SNA        11
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-DECnet" role="macro">
<title>GSS_C_AF_DECnet</title>
<indexterm zone="GSS-C-AF-DECnet"><primary>GSS_C_AF_DECnet</primary></indexterm>
<programlisting>#define GSS_C_AF_DECnet     12
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-DLI:CAPS" role="macro">
<title>GSS_C_AF_DLI</title>
<indexterm zone="GSS-C-AF-DLI:CAPS"><primary>GSS_C_AF_DLI</primary></indexterm>
<programlisting>#define GSS_C_AF_DLI        13
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-LAT:CAPS" role="macro">
<title>GSS_C_AF_LAT</title>
<indexterm zone="GSS-C-AF-LAT:CAPS"><primary>GSS_C_AF_LAT</primary></indexterm>
<programlisting>#define GSS_C_AF_LAT        14
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-HYLINK:CAPS" role="macro">
<title>GSS_C_AF_HYLINK</title>
<indexterm zone="GSS-C-AF-HYLINK:CAPS"><primary>GSS_C_AF_HYLINK</primary></indexterm>
<programlisting>#define GSS_C_AF_HYLINK     15
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-APPLETALK:CAPS" role="macro">
<title>GSS_C_AF_APPLETALK</title>
<indexterm zone="GSS-C-AF-APPLETALK:CAPS"><primary>GSS_C_AF_APPLETALK</primary></indexterm>
<programlisting>#define GSS_C_AF_APPLETALK  16
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-BSC:CAPS" role="macro">
<title>GSS_C_AF_BSC</title>
<indexterm zone="GSS-C-AF-BSC:CAPS"><primary>GSS_C_AF_BSC</primary></indexterm>
<programlisting>#define GSS_C_AF_BSC        17
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-DSS:CAPS" role="macro">
<title>GSS_C_AF_DSS</title>
<indexterm zone="GSS-C-AF-DSS:CAPS"><primary>GSS_C_AF_DSS</primary></indexterm>
<programlisting>#define GSS_C_AF_DSS        18
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-OSI:CAPS" role="macro">
<title>GSS_C_AF_OSI</title>
<indexterm zone="GSS-C-AF-OSI:CAPS"><primary>GSS_C_AF_OSI</primary></indexterm>
<programlisting>#define GSS_C_AF_OSI        19
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-X25:CAPS" role="macro">
<title>GSS_C_AF_X25</title>
<indexterm zone="GSS-C-AF-X25:CAPS"><primary>GSS_C_AF_X25</primary></indexterm>
<programlisting>#define GSS_C_AF_X25        21
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-AF-NULLADDR:CAPS" role="macro">
<title>GSS_C_AF_NULLADDR</title>
<indexterm zone="GSS-C-AF-NULLADDR:CAPS"><primary>GSS_C_AF_NULLADDR</primary></indexterm>
<programlisting>#define GSS_C_AF_NULLADDR   255
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-NO-NAME:CAPS" role="macro">
<title>GSS_C_NO_NAME</title>
<indexterm zone="GSS-C-NO-NAME:CAPS"><primary>GSS_C_NO_NAME</primary></indexterm>
<programlisting>#define GSS_C_NO_NAME ((gss_name_t) 0)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-NO-BUFFER:CAPS" role="macro">
<title>GSS_C_NO_BUFFER</title>
<indexterm zone="GSS-C-NO-BUFFER:CAPS"><primary>GSS_C_NO_BUFFER</primary></indexterm>
<programlisting>#define GSS_C_NO_BUFFER ((gss_buffer_t) 0)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-NO-OID:CAPS" role="macro">
<title>GSS_C_NO_OID</title>
<indexterm zone="GSS-C-NO-OID:CAPS"><primary>GSS_C_NO_OID</primary></indexterm>
<programlisting>#define GSS_C_NO_OID ((gss_OID) 0)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-NO-OID-SET:CAPS" role="macro">
<title>GSS_C_NO_OID_SET</title>
<indexterm zone="GSS-C-NO-OID-SET:CAPS"><primary>GSS_C_NO_OID_SET</primary></indexterm>
<programlisting>#define GSS_C_NO_OID_SET ((gss_OID_set) 0)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-NO-CONTEXT:CAPS" role="macro">
<title>GSS_C_NO_CONTEXT</title>
<indexterm zone="GSS-C-NO-CONTEXT:CAPS"><primary>GSS_C_NO_CONTEXT</primary></indexterm>
<programlisting>#define GSS_C_NO_CONTEXT ((gss_ctx_id_t) 0)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-NO-CREDENTIAL:CAPS" role="macro">
<title>GSS_C_NO_CREDENTIAL</title>
<indexterm zone="GSS-C-NO-CREDENTIAL:CAPS"><primary>GSS_C_NO_CREDENTIAL</primary></indexterm>
<programlisting>#define GSS_C_NO_CREDENTIAL ((gss_cred_id_t) 0)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-NO-CHANNEL-BINDINGS:CAPS" role="macro">
<title>GSS_C_NO_CHANNEL_BINDINGS</title>
<indexterm zone="GSS-C-NO-CHANNEL-BINDINGS:CAPS"><primary>GSS_C_NO_CHANNEL_BINDINGS</primary></indexterm>
<programlisting>#define GSS_C_NO_CHANNEL_BINDINGS ((gss_channel_bindings_t) 0)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-EMPTY-BUFFER:CAPS" role="macro">
<title>GSS_C_EMPTY_BUFFER</title>
<indexterm zone="GSS-C-EMPTY-BUFFER:CAPS"><primary>GSS_C_EMPTY_BUFFER</primary></indexterm>
<programlisting>#define GSS_C_EMPTY_BUFFER {0, NULL}
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-NULL-OID:CAPS" role="macro">
<title>GSS_C_NULL_OID</title>
<indexterm zone="GSS-C-NULL-OID:CAPS"><primary>GSS_C_NULL_OID</primary></indexterm>
<programlisting>#define GSS_C_NULL_OID GSS_C_NO_OID
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-NULL-OID-SET:CAPS" role="macro">
<title>GSS_C_NULL_OID_SET</title>
<indexterm zone="GSS-C-NULL-OID-SET:CAPS"><primary>GSS_C_NULL_OID_SET</primary></indexterm>
<programlisting>#define GSS_C_NULL_OID_SET GSS_C_NO_OID_SET
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-QOP-DEFAULT:CAPS" role="macro">
<title>GSS_C_QOP_DEFAULT</title>
<indexterm zone="GSS-C-QOP-DEFAULT:CAPS"><primary>GSS_C_QOP_DEFAULT</primary></indexterm>
<programlisting>#define GSS_C_QOP_DEFAULT 0
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-INDEFINITE:CAPS" role="macro">
<title>GSS_C_INDEFINITE</title>
<indexterm zone="GSS-C-INDEFINITE:CAPS"><primary>GSS_C_INDEFINITE</primary></indexterm>
<programlisting>#define GSS_C_INDEFINITE 0xfffffffful
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-NT-USER-NAME:CAPS" role="variable">
<title>GSS_C_NT_USER_NAME</title>
<indexterm zone="GSS-C-NT-USER-NAME:CAPS"><primary>GSS_C_NT_USER_NAME</primary></indexterm>
<programlisting>extern gss_OID GSS_C_NT_USER_NAME;
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-NT-MACHINE-UID-NAME:CAPS" role="variable">
<title>GSS_C_NT_MACHINE_UID_NAME</title>
<indexterm zone="GSS-C-NT-MACHINE-UID-NAME:CAPS"><primary>GSS_C_NT_MACHINE_UID_NAME</primary></indexterm>
<programlisting>extern gss_OID GSS_C_NT_MACHINE_UID_NAME;
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-NT-STRING-UID-NAME:CAPS" role="variable">
<title>GSS_C_NT_STRING_UID_NAME</title>
<indexterm zone="GSS-C-NT-STRING-UID-NAME:CAPS"><primary>GSS_C_NT_STRING_UID_NAME</primary></indexterm>
<programlisting>extern gss_OID GSS_C_NT_STRING_UID_NAME;
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-NT-HOSTBASED-SERVICE-X:CAPS" role="variable">
<title>GSS_C_NT_HOSTBASED_SERVICE_X</title>
<indexterm zone="GSS-C-NT-HOSTBASED-SERVICE-X:CAPS"><primary>GSS_C_NT_HOSTBASED_SERVICE_X</primary></indexterm>
<programlisting>extern gss_OID GSS_C_NT_HOSTBASED_SERVICE_X;
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-NT-HOSTBASED-SERVICE:CAPS" role="variable">
<title>GSS_C_NT_HOSTBASED_SERVICE</title>
<indexterm zone="GSS-C-NT-HOSTBASED-SERVICE:CAPS"><primary>GSS_C_NT_HOSTBASED_SERVICE</primary></indexterm>
<programlisting>extern gss_OID GSS_C_NT_HOSTBASED_SERVICE;
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-NT-ANONYMOUS:CAPS" role="variable">
<title>GSS_C_NT_ANONYMOUS</title>
<indexterm zone="GSS-C-NT-ANONYMOUS:CAPS"><primary>GSS_C_NT_ANONYMOUS</primary></indexterm>
<programlisting>extern gss_OID GSS_C_NT_ANONYMOUS;
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-NT-EXPORT-NAME:CAPS" role="variable">
<title>GSS_C_NT_EXPORT_NAME</title>
<indexterm zone="GSS-C-NT-EXPORT-NAME:CAPS"><primary>GSS_C_NT_EXPORT_NAME</primary></indexterm>
<programlisting>extern gss_OID GSS_C_NT_EXPORT_NAME;
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-COMPLETE:CAPS" role="macro">
<title>GSS_S_COMPLETE</title>
<indexterm zone="GSS-S-COMPLETE:CAPS"><primary>GSS_S_COMPLETE</primary></indexterm>
<programlisting>#define GSS_S_COMPLETE 0
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-CALLING-ERROR-OFFSET:CAPS" role="macro">
<title>GSS_C_CALLING_ERROR_OFFSET</title>
<indexterm zone="GSS-C-CALLING-ERROR-OFFSET:CAPS"><primary>GSS_C_CALLING_ERROR_OFFSET</primary></indexterm>
<programlisting>#define GSS_C_CALLING_ERROR_OFFSET 24
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-ROUTINE-ERROR-OFFSET:CAPS" role="macro">
<title>GSS_C_ROUTINE_ERROR_OFFSET</title>
<indexterm zone="GSS-C-ROUTINE-ERROR-OFFSET:CAPS"><primary>GSS_C_ROUTINE_ERROR_OFFSET</primary></indexterm>
<programlisting>#define GSS_C_ROUTINE_ERROR_OFFSET 16
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-SUPPLEMENTARY-OFFSET:CAPS" role="macro">
<title>GSS_C_SUPPLEMENTARY_OFFSET</title>
<indexterm zone="GSS-C-SUPPLEMENTARY-OFFSET:CAPS"><primary>GSS_C_SUPPLEMENTARY_OFFSET</primary></indexterm>
<programlisting>#define GSS_C_SUPPLEMENTARY_OFFSET 0
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-CALLING-ERROR-MASK:CAPS" role="macro">
<title>GSS_C_CALLING_ERROR_MASK</title>
<indexterm zone="GSS-C-CALLING-ERROR-MASK:CAPS"><primary>GSS_C_CALLING_ERROR_MASK</primary></indexterm>
<programlisting>#define GSS_C_CALLING_ERROR_MASK 0377ul
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-ROUTINE-ERROR-MASK:CAPS" role="macro">
<title>GSS_C_ROUTINE_ERROR_MASK</title>
<indexterm zone="GSS-C-ROUTINE-ERROR-MASK:CAPS"><primary>GSS_C_ROUTINE_ERROR_MASK</primary></indexterm>
<programlisting>#define GSS_C_ROUTINE_ERROR_MASK 0377ul
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-C-SUPPLEMENTARY-MASK:CAPS" role="macro">
<title>GSS_C_SUPPLEMENTARY_MASK</title>
<indexterm zone="GSS-C-SUPPLEMENTARY-MASK:CAPS"><primary>GSS_C_SUPPLEMENTARY_MASK</primary></indexterm>
<programlisting>#define GSS_C_SUPPLEMENTARY_MASK 0177777ul
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-CALLING-ERROR:CAPS" role="macro">
<title>GSS_CALLING_ERROR()</title>
<indexterm zone="GSS-CALLING-ERROR:CAPS"><primary>GSS_CALLING_ERROR</primary></indexterm>
<programlisting>#define             GSS_CALLING_ERROR(x)</programlisting>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>x</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="GSS-ROUTINE-ERROR:CAPS" role="macro">
<title>GSS_ROUTINE_ERROR()</title>
<indexterm zone="GSS-ROUTINE-ERROR:CAPS"><primary>GSS_ROUTINE_ERROR</primary></indexterm>
<programlisting>#define             GSS_ROUTINE_ERROR(x)</programlisting>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>x</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="GSS-SUPPLEMENTARY-INFO:CAPS" role="macro">
<title>GSS_SUPPLEMENTARY_INFO()</title>
<indexterm zone="GSS-SUPPLEMENTARY-INFO:CAPS"><primary>GSS_SUPPLEMENTARY_INFO</primary></indexterm>
<programlisting>#define             GSS_SUPPLEMENTARY_INFO(x)</programlisting>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>x</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="GSS-ERROR:CAPS" role="macro">
<title>GSS_ERROR()</title>
<indexterm zone="GSS-ERROR:CAPS"><primary>GSS_ERROR</primary></indexterm>
<programlisting>#define             GSS_ERROR(x)</programlisting>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>x</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="GSS-S-CALL-INACCESSIBLE-READ:CAPS" role="macro">
<title>GSS_S_CALL_INACCESSIBLE_READ</title>
<indexterm zone="GSS-S-CALL-INACCESSIBLE-READ:CAPS"><primary>GSS_S_CALL_INACCESSIBLE_READ</primary></indexterm>
<programlisting>#define GSS_S_CALL_INACCESSIBLE_READ&#160;(1ul &lt;&lt; GSS_C_CALLING_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-CALL-INACCESSIBLE-WRITE:CAPS" role="macro">
<title>GSS_S_CALL_INACCESSIBLE_WRITE</title>
<indexterm zone="GSS-S-CALL-INACCESSIBLE-WRITE:CAPS"><primary>GSS_S_CALL_INACCESSIBLE_WRITE</primary></indexterm>
<programlisting>#define GSS_S_CALL_INACCESSIBLE_WRITE&#160;(2ul &lt;&lt; GSS_C_CALLING_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-CALL-BAD-STRUCTURE:CAPS" role="macro">
<title>GSS_S_CALL_BAD_STRUCTURE</title>
<indexterm zone="GSS-S-CALL-BAD-STRUCTURE:CAPS"><primary>GSS_S_CALL_BAD_STRUCTURE</primary></indexterm>
<programlisting>#define GSS_S_CALL_BAD_STRUCTURE&#160;(3ul &lt;&lt; GSS_C_CALLING_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-BAD-MECH:CAPS" role="macro">
<title>GSS_S_BAD_MECH</title>
<indexterm zone="GSS-S-BAD-MECH:CAPS"><primary>GSS_S_BAD_MECH</primary></indexterm>
<programlisting>#define GSS_S_BAD_MECH             (1ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-BAD-NAME:CAPS" role="macro">
<title>GSS_S_BAD_NAME</title>
<indexterm zone="GSS-S-BAD-NAME:CAPS"><primary>GSS_S_BAD_NAME</primary></indexterm>
<programlisting>#define GSS_S_BAD_NAME             (2ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-BAD-NAMETYPE:CAPS" role="macro">
<title>GSS_S_BAD_NAMETYPE</title>
<indexterm zone="GSS-S-BAD-NAMETYPE:CAPS"><primary>GSS_S_BAD_NAMETYPE</primary></indexterm>
<programlisting>#define GSS_S_BAD_NAMETYPE         (3ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-BAD-BINDINGS:CAPS" role="macro">
<title>GSS_S_BAD_BINDINGS</title>
<indexterm zone="GSS-S-BAD-BINDINGS:CAPS"><primary>GSS_S_BAD_BINDINGS</primary></indexterm>
<programlisting>#define GSS_S_BAD_BINDINGS         (4ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-BAD-STATUS:CAPS" role="macro">
<title>GSS_S_BAD_STATUS</title>
<indexterm zone="GSS-S-BAD-STATUS:CAPS"><primary>GSS_S_BAD_STATUS</primary></indexterm>
<programlisting>#define GSS_S_BAD_STATUS           (5ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-BAD-SIG:CAPS" role="macro">
<title>GSS_S_BAD_SIG</title>
<indexterm zone="GSS-S-BAD-SIG:CAPS"><primary>GSS_S_BAD_SIG</primary></indexterm>
<programlisting>#define GSS_S_BAD_SIG              (6ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-BAD-MIC:CAPS" role="macro">
<title>GSS_S_BAD_MIC</title>
<indexterm zone="GSS-S-BAD-MIC:CAPS"><primary>GSS_S_BAD_MIC</primary></indexterm>
<programlisting>#define GSS_S_BAD_MIC GSS_S_BAD_SIG
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-NO-CRED:CAPS" role="macro">
<title>GSS_S_NO_CRED</title>
<indexterm zone="GSS-S-NO-CRED:CAPS"><primary>GSS_S_NO_CRED</primary></indexterm>
<programlisting>#define GSS_S_NO_CRED              (7ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-NO-CONTEXT:CAPS" role="macro">
<title>GSS_S_NO_CONTEXT</title>
<indexterm zone="GSS-S-NO-CONTEXT:CAPS"><primary>GSS_S_NO_CONTEXT</primary></indexterm>
<programlisting>#define GSS_S_NO_CONTEXT           (8ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-DEFECTIVE-TOKEN:CAPS" role="macro">
<title>GSS_S_DEFECTIVE_TOKEN</title>
<indexterm zone="GSS-S-DEFECTIVE-TOKEN:CAPS"><primary>GSS_S_DEFECTIVE_TOKEN</primary></indexterm>
<programlisting>#define GSS_S_DEFECTIVE_TOKEN      (9ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-DEFECTIVE-CREDENTIAL:CAPS" role="macro">
<title>GSS_S_DEFECTIVE_CREDENTIAL</title>
<indexterm zone="GSS-S-DEFECTIVE-CREDENTIAL:CAPS"><primary>GSS_S_DEFECTIVE_CREDENTIAL</primary></indexterm>
<programlisting>#define GSS_S_DEFECTIVE_CREDENTIAL (10ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-CREDENTIALS-EXPIRED:CAPS" role="macro">
<title>GSS_S_CREDENTIALS_EXPIRED</title>
<indexterm zone="GSS-S-CREDENTIALS-EXPIRED:CAPS"><primary>GSS_S_CREDENTIALS_EXPIRED</primary></indexterm>
<programlisting>#define GSS_S_CREDENTIALS_EXPIRED  (11ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-CONTEXT-EXPIRED:CAPS" role="macro">
<title>GSS_S_CONTEXT_EXPIRED</title>
<indexterm zone="GSS-S-CONTEXT-EXPIRED:CAPS"><primary>GSS_S_CONTEXT_EXPIRED</primary></indexterm>
<programlisting>#define GSS_S_CONTEXT_EXPIRED      (12ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-FAILURE:CAPS" role="macro">
<title>GSS_S_FAILURE</title>
<indexterm zone="GSS-S-FAILURE:CAPS"><primary>GSS_S_FAILURE</primary></indexterm>
<programlisting>#define GSS_S_FAILURE              (13ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-BAD-QOP:CAPS" role="macro">
<title>GSS_S_BAD_QOP</title>
<indexterm zone="GSS-S-BAD-QOP:CAPS"><primary>GSS_S_BAD_QOP</primary></indexterm>
<programlisting>#define GSS_S_BAD_QOP              (14ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-UNAUTHORIZED:CAPS" role="macro">
<title>GSS_S_UNAUTHORIZED</title>
<indexterm zone="GSS-S-UNAUTHORIZED:CAPS"><primary>GSS_S_UNAUTHORIZED</primary></indexterm>
<programlisting>#define GSS_S_UNAUTHORIZED         (15ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-UNAVAILABLE:CAPS" role="macro">
<title>GSS_S_UNAVAILABLE</title>
<indexterm zone="GSS-S-UNAVAILABLE:CAPS"><primary>GSS_S_UNAVAILABLE</primary></indexterm>
<programlisting>#define GSS_S_UNAVAILABLE          (16ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-DUPLICATE-ELEMENT:CAPS" role="macro">
<title>GSS_S_DUPLICATE_ELEMENT</title>
<indexterm zone="GSS-S-DUPLICATE-ELEMENT:CAPS"><primary>GSS_S_DUPLICATE_ELEMENT</primary></indexterm>
<programlisting>#define GSS_S_DUPLICATE_ELEMENT    (17ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-NAME-NOT-MN:CAPS" role="macro">
<title>GSS_S_NAME_NOT_MN</title>
<indexterm zone="GSS-S-NAME-NOT-MN:CAPS"><primary>GSS_S_NAME_NOT_MN</primary></indexterm>
<programlisting>#define GSS_S_NAME_NOT_MN          (18ul &lt;&lt; GSS_C_ROUTINE_ERROR_OFFSET)
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-CONTINUE-NEEDED:CAPS" role="macro">
<title>GSS_S_CONTINUE_NEEDED</title>
<indexterm zone="GSS-S-CONTINUE-NEEDED:CAPS"><primary>GSS_S_CONTINUE_NEEDED</primary></indexterm>
<programlisting>#define GSS_S_CONTINUE_NEEDED&#160;(1ul &lt;&lt; (GSS_C_SUPPLEMENTARY_OFFSET + 0))
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-DUPLICATE-TOKEN:CAPS" role="macro">
<title>GSS_S_DUPLICATE_TOKEN</title>
<indexterm zone="GSS-S-DUPLICATE-TOKEN:CAPS"><primary>GSS_S_DUPLICATE_TOKEN</primary></indexterm>
<programlisting>#define GSS_S_DUPLICATE_TOKEN&#160;(1ul &lt;&lt; (GSS_C_SUPPLEMENTARY_OFFSET + 1))
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-OLD-TOKEN:CAPS" role="macro">
<title>GSS_S_OLD_TOKEN</title>
<indexterm zone="GSS-S-OLD-TOKEN:CAPS"><primary>GSS_S_OLD_TOKEN</primary></indexterm>
<programlisting>#define GSS_S_OLD_TOKEN		(1ul &lt;&lt; (GSS_C_SUPPLEMENTARY_OFFSET + 2))
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-UNSEQ-TOKEN:CAPS" role="macro">
<title>GSS_S_UNSEQ_TOKEN</title>
<indexterm zone="GSS-S-UNSEQ-TOKEN:CAPS"><primary>GSS_S_UNSEQ_TOKEN</primary></indexterm>
<programlisting>#define GSS_S_UNSEQ_TOKEN&#160;(1ul &lt;&lt; (GSS_C_SUPPLEMENTARY_OFFSET + 3))
</programlisting>
<para>
</para></refsect2>
<refsect2 id="GSS-S-GAP-TOKEN:CAPS" role="macro">
<title>GSS_S_GAP_TOKEN</title>
<indexterm zone="GSS-S-GAP-TOKEN:CAPS"><primary>GSS_S_GAP_TOKEN</primary></indexterm>
<programlisting>#define GSS_S_GAP_TOKEN		(1ul &lt;&lt; (GSS_C_SUPPLEMENTARY_OFFSET + 4))
</programlisting>
<para>
</para></refsect2>
<refsect2 id="gss-acquire-cred" role="function">
<title>gss_acquire_cred ()</title>
<indexterm zone="gss-acquire-cred"><primary>gss_acquire_cred</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_acquire_cred                    (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> desired_name</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> time_req</parameter>,
                                                         <parameter>const <link linkend="gss-OID-set"><type>gss_OID_set</type></link> desired_mechs</parameter>,
                                                         <parameter><link linkend="gss-cred-usage-t"><type>gss_cred_usage_t</type></link> cred_usage</parameter>,
                                                         <parameter><link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> *output_cred_handle</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *actual_mechs</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *time_rec</parameter>);</programlisting>
<para>
Allows an application to acquire a handle for a pre-existing
credential by name.  GSS-API implementations must impose a local
access-control policy on callers of this routine to prevent
unauthorized callers from acquiring credentials to which they are
not entitled.  This routine is not intended to provide a "login to
the network" function, as such a function would involve the
creation of new credentials rather than merely acquiring a handle
to existing credentials.  Such functions, if required, should be
defined in implementation-specific extensions to the API.
</para>
<para>
If desired_name is GSS_C_NO_NAME, the call is interpreted as a
request for a credential handle that will invoke default behavior
when passed to <link linkend="gss-init-sec-context"><function>gss_init_sec_context()</function></link> (if cred_usage is
GSS_C_INITIATE or GSS_C_BOTH) or <link linkend="gss-accept-sec-context"><function>gss_accept_sec_context()</function></link> (if
cred_usage is GSS_C_ACCEPT or GSS_C_BOTH).
</para>
<para>
Mechanisms should honor the desired_mechs parameter, and return a
credential that is suitable to use only with the requested
mechanisms.  An exception to this is the case where one underlying
credential element can be shared by multiple mechanisms; in this
case it is permissible for an implementation to indicate all
mechanisms with which the credential element may be used.  If
desired_mechs is an empty set, behavior is undefined.
</para>
<para>
This routine is expected to be used primarily by context acceptors,
since implementations are likely to provide mechanism-specific ways
of obtaining GSS-API initiator credentials from the system login
process.  Some implementations may therefore not support the
acquisition of GSS_C_INITIATE or GSS_C_BOTH credentials via
gss_acquire_cred for any name other than GSS_C_NO_NAME, or a name
produced by applying either gss_inquire_cred to a valid credential,
or gss_inquire_context to an active context.
</para>
<para>
If credential acquisition is time-consuming for a mechanism, the
mechanism may choose to delay the actual acquisition until the
credential is required (e.g. by gss_init_sec_context or
gss_accept_sec_context).  Such mechanism-specific implementation
decisions should be invisible to the calling application; thus a
call of gss_inquire_cred immediately following the call of
gss_acquire_cred must return valid credential data, and may
therefore incur the overhead of a deferred credential acquisition.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>desired_name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, read) Name of principal whose
  credential should be acquired.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>time_req</parameter>&#160;:</term>
<listitem><simpara>(Integer, read, optional) Number of seconds that
  credentials should remain valid. Specify GSS_C_INDEFINITE to
  request that the credentials have the maximum permitted lifetime.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>desired_mechs</parameter>&#160;:</term>
<listitem><simpara>(Set of Object IDs, read, optional) Set of
  underlying security mechanisms that may be used.
  GSS_C_NO_OID_SET may be used to obtain an implementation-specific
  default.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>cred_usage</parameter>&#160;:</term>
<listitem><simpara>(gss_cred_usage_t, read) GSS_C_BOTH - Credentials may
  be used either to initiate or accept security contexts.
  GSS_C_INITIATE - Credentials will only be used to initiate
  security contexts.  GSS_C_ACCEPT - Credentials will only be used
  to accept security contexts.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>output_cred_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_cred_id_t, modify) The returned
  credential handle.  Resources associated with this credential
  handle must be released by the application after use with a call
  to <link linkend="gss-release-cred"><function>gss_release_cred()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>actual_mechs</parameter>&#160;:</term>
<listitem><simpara>(Set of Object IDs, modify, optional) The set of
  mechanisms for which the credential is valid.  Storage associated
  with the returned OID-set must be released by the application
  after use with a call to <link linkend="gss-release-oid-set"><function>gss_release_oid_set()</function></link>.  Specify NULL if
  not required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>time_rec</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify, optional) Actual number of seconds for
  which the returned credentials will remain valid.  If the
  implementation does not support expiration of credentials, the
  value GSS_C_INDEFINITE will be returned. Specify NULL if not
  required.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_BAD_MECH`: Unavailable mechanism requested.

`GSS_S_BAD_NAMETYPE`: Type contained within desired_name parameter
is not supported.

`GSS_S_BAD_NAME`: Value supplied for desired_name parameter is ill
formed.

`GSS_S_CREDENTIALS_EXPIRED`: The credentials could not be acquired
Because they have expired.

`GSS_S_NO_CRED`: No credentials were found for the specified name.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-release-cred" role="function">
<title>gss_release_cred ()</title>
<indexterm zone="gss-release-cred"><primary>gss_release_cred</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_release_cred                    (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> *cred_handle</parameter>);</programlisting>
<para>
Informs GSS-API that the specified credential handle is no longer
required by the application, and frees associated resources.  The
cred_handle is set to GSS_C_NO_CREDENTIAL on successful completion
of this call.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>cred_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_cred_id_t, modify, optional) Opaque handle
  identifying credential to be released.  If GSS_C_NO_CREDENTIAL is
  supplied, the routine will complete successfully, but will do
  nothing.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_NO_CRED`: Credentials could not be accessed.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-init-sec-context" role="function">
<title>gss_init_sec_context ()</title>
<indexterm zone="gss-init-sec-context"><primary>gss_init_sec_context</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_init_sec_context                (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> initiator_cred_handle</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> *context_handle</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> target_name</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> mech_type</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> req_flags</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> time_req</parameter>,
                                                         <parameter>const <link linkend="gss-channel-bindings-t"><type>gss_channel_bindings_t</type></link> input_chan_bindings</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> input_token</parameter>,
                                                         <parameter><link linkend="gss-OID"><type>gss_OID</type></link> *actual_mech_type</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> output_token</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *ret_flags</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *time_rec</parameter>);</programlisting>
<para>
Initiates the establishment of a security context between the
application and a remote peer.  Initially, the input_token
parameter should be specified either as GSS_C_NO_BUFFER, or as a
pointer to a gss_buffer_desc object whose length field contains the
value zero.  The routine may return a output_token which should be
transferred to the peer application, where the peer application
will present it to gss_accept_sec_context.  If no token need be
sent, gss_init_sec_context will indicate this by setting the length
field of the output_token argument to zero. To complete the context
establishment, one or more reply tokens may be required from the
peer application; if so, gss_init_sec_context will return a status
containing the supplementary information bit GSS_S_CONTINUE_NEEDED.
In this case, gss_init_sec_context should be called again when the
reply token is received from the peer application, passing the
reply token to gss_init_sec_context via the input_token parameters.
</para>
<para>
Portable applications should be constructed to use the token length
and return status to determine whether a token needs to be sent or
waited for.  Thus a typical portable caller should always invoke
gss_init_sec_context within a loop:
</para>
<para>
---------------------------------------------------
int context_established = 0;
gss_ctx_id_t context_hdl = GSS_C_NO_CONTEXT;
       ...
input_token->length = 0;
</para>
<para>
while (!context_established) {
  maj_stat = gss_init_sec_context(&amp;min_stat,
                                  cred_hdl,
                                  &amp;context_hdl,
                                  target_name,
                                  desired_mech,
                                  desired_services,
                                  desired_time,
                                  input_bindings,
                                  input_token,
                                  &amp;actual_mech,
                                  output_token,
                                  &amp;actual_services,
                                  &amp;actual_time);
  if (GSS_ERROR(maj_stat)) {
    report_error(maj_stat, min_stat);
  };
</para>
<para>
  if (output_token->length != 0) {
    send_token_to_peer(output_token);
    gss_release_buffer(&amp;min_stat, output_token)
  };
  if (GSS_ERROR(maj_stat)) {
</para>
<para>
    if (context_hdl != GSS_C_NO_CONTEXT)
      gss_delete_sec_context(&amp;min_stat,
                             &amp;context_hdl,
                             GSS_C_NO_BUFFER);
    break;
  };
</para>
<para>
  if (maj_stat &amp; GSS_S_CONTINUE_NEEDED) {
    receive_token_from_peer(input_token);
  } else {
    context_established = 1;
  };
};
---------------------------------------------------
</para>
<para>
Whenever the routine returns a major status that includes the value
GSS_S_CONTINUE_NEEDED, the context is not fully established and the
following restrictions apply to the output parameters:
</para>
<para>
- The value returned via the time_rec parameter is undefined unless
the accompanying ret_flags parameter contains the bit
GSS_C_PROT_READY_FLAG, indicating that per-message services may be
applied in advance of a successful completion status, the value
returned via the actual_mech_type parameter is undefined until the
routine returns a major status value of GSS_S_COMPLETE.
</para>
<para>
- The values of the GSS_C_DELEG_FLAG, GSS_C_MUTUAL_FLAG,
GSS_C_REPLAY_FLAG, GSS_C_SEQUENCE_FLAG, GSS_C_CONF_FLAG,
GSS_C_INTEG_FLAG and GSS_C_ANON_FLAG bits returned via the
ret_flags parameter should contain the values that the
implementation expects would be valid if context establishment were
to succeed.  In particular, if the application has requested a
service such as delegation or anonymous authentication via the
req_flags argument, and such a service is unavailable from the
underlying mechanism, gss_init_sec_context should generate a token
that will not provide the service, and indicate via the ret_flags
argument that the service will not be supported.  The application
may choose to abort the context establishment by calling
gss_delete_sec_context (if it cannot continue in the absence of the
service), or it may choose to transmit the token and continue
context establishment (if the service was merely desired but not
mandatory).
</para>
<para>
- The values of the GSS_C_PROT_READY_FLAG and GSS_C_TRANS_FLAG bits
within ret_flags should indicate the actual state at the time
gss_init_sec_context returns, whether or not the context is fully
established.
</para>
<para>
- GSS-API implementations that support per-message protection are
encouraged to set the GSS_C_PROT_READY_FLAG in the final ret_flags
returned to a caller (i.e. when accompanied by a GSS_S_COMPLETE
status code).  However, applications should not rely on this
behavior as the flag was not defined in Version 1 of the GSS-API.
Instead, applications should determine what per-message services
are available after a successful context establishment according to
the GSS_C_INTEG_FLAG and GSS_C_CONF_FLAG values.
</para>
<para>
- All other bits within the ret_flags argument should be set to
zero.
</para>
<para>
If the initial call of <link linkend="gss-init-sec-context"><function>gss_init_sec_context()</function></link> fails, the
implementation should not create a context object, and should leave
the value of the context_handle parameter set to GSS_C_NO_CONTEXT
to indicate this.  In the event of a failure on a subsequent call,
the implementation is permitted to delete the "half-built" security
context (in which case it should set the context_handle parameter
to GSS_C_NO_CONTEXT), but the preferred behavior is to leave the
security context untouched for the application to delete (using
gss_delete_sec_context).
</para>
<para>
During context establishment, the informational status bits
GSS_S_OLD_TOKEN and GSS_S_DUPLICATE_TOKEN indicate fatal errors,
and GSS-API mechanisms should always return them in association
with a routine error of GSS_S_FAILURE.  This requirement for
pairing did not exist in version 1 of the GSS-API specification, so
applications that wish to run over version 1 implementations must
special-case these codes.
</para>
<para>
The `req_flags` values:
</para>
<para>
`GSS_C_DELEG_FLAG`::
- True - Delegate credentials to remote peer.
- False - Don't delegate.
</para>
<para>
`GSS_C_MUTUAL_FLAG`::
- True - Request that remote peer authenticate itself.
- False - Authenticate self to remote peer only.
</para>
<para>
`GSS_C_REPLAY_FLAG`::
- True - Enable replay detection for messages protected with
gss_wrap or gss_get_mic.
- False - Don't attempt to detect replayed messages.
</para>
<para>
`GSS_C_SEQUENCE_FLAG`::
- True - Enable detection of out-of-sequence protected messages.
- False - Don't attempt to detect out-of-sequence messages.
</para>
<para>
`GSS_C_CONF_FLAG`::
- True - Request that confidentiality service be made available
(via gss_wrap).
- False - No per-message confidentiality service is required.
</para>
<para>
`GSS_C_INTEG_FLAG`::
- True - Request that integrity service be made available (via
gss_wrap or gss_get_mic).
- False - No per-message integrity service is required.
</para>
<para>
`GSS_C_ANON_FLAG`::
- True - Do not reveal the initiator's identity to the acceptor.
- False - Authenticate normally.
</para>
<para>
The `ret_flags` values:
</para>
<para>
`GSS_C_DELEG_FLAG`::
- True - Credentials were delegated to the remote peer.
- False - No credentials were delegated.
</para>
<para>
`GSS_C_MUTUAL_FLAG`::
- True - The remote peer has authenticated itself.
- False - Remote peer has not authenticated itself.
</para>
<para>
`GSS_C_REPLAY_FLAG`::
- True - replay of protected messages will be detected.
- False - replayed messages will not be detected.
</para>
<para>
`GSS_C_SEQUENCE_FLAG`::
- True - out-of-sequence protected messages will be detected.
- False - out-of-sequence messages will not be detected.
</para>
<para>
`GSS_C_CONF_FLAG`::
- True - Confidentiality service may be invoked by calling gss_wrap
routine.
- False - No confidentiality service (via gss_wrap)
available. gss_wrap will provide message encapsulation, data-origin
authentication and integrity services only.
</para>
<para>
`GSS_C_INTEG_FLAG`::
- True - Integrity service may be invoked by calling either
gss_get_mic or gss_wrap routines.
- False - Per-message integrity service unavailable.
</para>
<para>
`GSS_C_ANON_FLAG`::
- True - The initiator's identity has not been revealed, and will
not be revealed if any emitted token is passed to the acceptor.
- False - The initiator's identity has been or will be
authenticated normally.
</para>
<para>
`GSS_C_PROT_READY_FLAG`::
- True - Protection services (as specified by the states of the
GSS_C_CONF_FLAG and GSS_C_INTEG_FLAG) are available for use if the
accompanying major status return value is either GSS_S_COMPLETE or
GSS_S_CONTINUE_NEEDED.
- False - Protection services (as specified by the states of the
GSS_C_CONF_FLAG and GSS_C_INTEG_FLAG) are available only if the
accompanying major status return value is GSS_S_COMPLETE.
</para>
<para>
`GSS_C_TRANS_FLAG`::
- True - The resultant security context may be transferred to other
processes via a call to <link linkend="gss-export-sec-context"><function>gss_export_sec_context()</function></link>.
- False - The security context is not transferable.
</para>
<para>
All other bits should be set to zero.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>initiator_cred_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_cred_id_t, read, optional) Handle for
  credentials claimed.  Supply GSS_C_NO_CREDENTIAL to act as a
  default initiator principal.  If no default initiator is defined,
  the function will return GSS_S_NO_CRED.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_ctx_id_t, read/modify) Context handle for new
  context.  Supply GSS_C_NO_CONTEXT for first call; use value
  returned by first call in continuation calls.  Resources
  associated with this context-handle must be released by the
  application after use with a call to <link linkend="gss-delete-sec-context"><function>gss_delete_sec_context()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>target_name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, read) Name of target.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mech_type</parameter>&#160;:</term>
<listitem><simpara>(OID, read, optional) Object ID of desired
  mechanism. Supply GSS_C_NO_OID to obtain an implementation
  specific default.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>req_flags</parameter>&#160;:</term>
<listitem><simpara>(bit-mask, read) Contains various independent flags,
  each of which requests that the context support a specific
  service option.  Symbolic names are provided for each flag, and
  the symbolic names corresponding to the required flags should be
  logically-ORed together to form the bit-mask value.  See below
  for the flags.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>time_req</parameter>&#160;:</term>
<listitem><simpara>(Integer, read, optional) Desired number of seconds for
  which context should remain valid.  Supply 0 to request a default
  validity period.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>input_chan_bindings</parameter>&#160;:</term>
<listitem><simpara>(channel bindings, read, optional)
  Application-specified bindings.  Allows application to securely
  bind channel identification information to the security context.
  Specify GSS_C_NO_CHANNEL_BINDINGS if channel bindings are not
  used.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>input_token</parameter>&#160;:</term>
<listitem><simpara>(buffer, opaque, read, optional) Token received from
  peer application.  Supply GSS_C_NO_BUFFER, or a pointer to a
  buffer containing the value GSS_C_EMPTY_BUFFER on initial call.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>actual_mech_type</parameter>&#160;:</term>
<listitem><simpara>(OID, modify, optional) Actual mechanism used.
  The OID returned via this parameter will be a pointer to static
  storage that should be treated as read-only; In particular the
  application should not attempt to free it.  Specify NULL if not
  required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>output_token</parameter>&#160;:</term>
<listitem><simpara>(buffer, opaque, modify) Token to be sent to peer
  application.  If the length field of the returned buffer is zero,
  no token need be sent to the peer application.  Storage
  associated with this buffer must be freed by the application
  after use with a call to <link linkend="gss-release-buffer"><function>gss_release_buffer()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>ret_flags</parameter>&#160;:</term>
<listitem><simpara>(bit-mask, modify, optional) Contains various
  independent flags, each of which indicates that the context
  supports a specific service option.  Specify NULL if not
  required.  Symbolic names are provided for each flag, and the
  symbolic names corresponding to the required flags should be
  logically-ANDed with the ret_flags value to test whether a given
  option is supported by the context.  See below for the flags.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>time_rec</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify, optional) Number of seconds for which
  the context will remain valid. If the implementation does not
  support context expiration, the value GSS_C_INDEFINITE will be
  returned.  Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_CONTINUE_NEEDED`: Indicates that a token from the peer
application is required to complete the context, and that
gss_init_sec_context must be called again with that token.

`GSS_S_DEFECTIVE_TOKEN`: Indicates that consistency checks
performed on the input_token failed.

`GSS_S_DEFECTIVE_CREDENTIAL`: Indicates that consistency checks
performed on the credential failed.

`GSS_S_NO_CRED`: The supplied credentials were not valid for
context initiation, or the credential handle did not reference any
credentials.

`GSS_S_CREDENTIALS_EXPIRED`: The referenced credentials have
expired.

`GSS_S_BAD_BINDINGS`: The input_token contains different channel
bindings to those specified via the input_chan_bindings parameter.

`GSS_S_BAD_SIG`: The input_token contains an invalid MIC, or a MIC
that could not be verified.

`GSS_S_OLD_TOKEN`: The input_token was too old.  This is a fatal
error during context establishment.

`GSS_S_DUPLICATE_TOKEN`: The input_token is valid, but is a
duplicate of a token already processed.  This is a fatal error
during context establishment.

`GSS_S_NO_CONTEXT`: Indicates that the supplied context handle did
not refer to a valid context.

`GSS_S_BAD_NAMETYPE`: The provided target_name parameter contained
an invalid or unsupported type of name.

`GSS_S_BAD_NAME`: The provided target_name parameter was
ill-formed.

`GSS_S_BAD_MECH`: The specified mechanism is not supported by the
provided credential, or is unrecognized by the implementation.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-accept-sec-context" role="function">
<title>gss_accept_sec_context ()</title>
<indexterm zone="gss-accept-sec-context"><primary>gss_accept_sec_context</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_accept_sec_context              (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> *context_handle</parameter>,
                                                         <parameter>const <link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> acceptor_cred_handle</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> input_token_buffer</parameter>,
                                                         <parameter>const <link linkend="gss-channel-bindings-t"><type>gss_channel_bindings_t</type></link> input_chan_bindings</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *src_name</parameter>,
                                                         <parameter><link linkend="gss-OID"><type>gss_OID</type></link> *mech_type</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> output_token</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *ret_flags</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *time_rec</parameter>,
                                                         <parameter><link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> *delegated_cred_handle</parameter>);</programlisting>
<para>
Allows a remotely initiated security context between the
application and a remote peer to be established.  The routine may
return a output_token which should be transferred to the peer
application, where the peer application will present it to
gss_init_sec_context.  If no token need be sent,
gss_accept_sec_context will indicate this by setting the length
field of the output_token argument to zero.  To complete the
context establishment, one or more reply tokens may be required
from the peer application; if so, gss_accept_sec_context will
return a status flag of GSS_S_CONTINUE_NEEDED, in which case it
should be called again when the reply token is received from the
peer application, passing the token to gss_accept_sec_context via
the input_token parameters.
</para>
<para>
Portable applications should be constructed to use the token length
and return status to determine whether a token needs to be sent or
waited for.  Thus a typical portable caller should always invoke
gss_accept_sec_context within a loop:
</para>
<para>
---------------------------------------------------
gss_ctx_id_t context_hdl = GSS_C_NO_CONTEXT;
</para>
<para>
do {
  receive_token_from_peer(input_token);
  maj_stat = gss_accept_sec_context(&amp;min_stat,
                                    &amp;context_hdl,
                                    cred_hdl,
                                    input_token,
                                    input_bindings,
                                    &amp;client_name,
                                    &amp;mech_type,
                                    output_token,
                                    &amp;ret_flags,
                                    &amp;time_rec,
                                    &amp;deleg_cred);
  if (GSS_ERROR(maj_stat)) {
    report_error(maj_stat, min_stat);
  };
  if (output_token->length != 0) {
    send_token_to_peer(output_token);
</para>
<para>
    gss_release_buffer(&amp;min_stat, output_token);
  };
  if (GSS_ERROR(maj_stat)) {
    if (context_hdl != GSS_C_NO_CONTEXT)
      gss_delete_sec_context(&amp;min_stat,
                             &amp;context_hdl,
                             GSS_C_NO_BUFFER);
    break;
  };
} while (maj_stat &amp; GSS_S_CONTINUE_NEEDED);
---------------------------------------------------
</para>
<para>
Whenever the routine returns a major status that includes the value
GSS_S_CONTINUE_NEEDED, the context is not fully established and the
following restrictions apply to the output parameters:
</para>
<para>
The value returned via the time_rec parameter is undefined Unless the
accompanying ret_flags parameter contains the bit
GSS_C_PROT_READY_FLAG, indicating that per-message services may be
applied in advance of a successful completion status, the value
returned via the mech_type parameter may be undefined until the
routine returns a major status value of GSS_S_COMPLETE.
</para>
<para>
The values of the GSS_C_DELEG_FLAG,
GSS_C_MUTUAL_FLAG,GSS_C_REPLAY_FLAG, GSS_C_SEQUENCE_FLAG,
GSS_C_CONF_FLAG,GSS_C_INTEG_FLAG and GSS_C_ANON_FLAG bits returned
via the ret_flags parameter should contain the values that the
implementation expects would be valid if context establishment were
to succeed.
</para>
<para>
The values of the GSS_C_PROT_READY_FLAG and GSS_C_TRANS_FLAG bits
within ret_flags should indicate the actual state at the time
gss_accept_sec_context returns, whether or not the context is fully
established.
</para>
<para>
Although this requires that GSS-API implementations set the
GSS_C_PROT_READY_FLAG in the final ret_flags returned to a caller
(i.e. when accompanied by a GSS_S_COMPLETE status code), applications
should not rely on this behavior as the flag was not defined in
Version 1 of the GSS-API. Instead, applications should be prepared to
use per-message services after a successful context establishment,
according to the GSS_C_INTEG_FLAG and GSS_C_CONF_FLAG values.
</para>
<para>
All other bits within the ret_flags argument should be set to zero.
While the routine returns GSS_S_CONTINUE_NEEDED, the values returned
via the ret_flags argument indicate the services that the
implementation expects to be available from the established context.
</para>
<para>
If the initial call of <link linkend="gss-accept-sec-context"><function>gss_accept_sec_context()</function></link> fails, the
implementation should not create a context object, and should leave
the value of the context_handle parameter set to GSS_C_NO_CONTEXT to
indicate this.  In the event of a failure on a subsequent call, the
implementation is permitted to delete the "half-built" security
context (in which case it should set the context_handle parameter to
GSS_C_NO_CONTEXT), but the preferred behavior is to leave the
security context (and the context_handle parameter) untouched for the
application to delete (using gss_delete_sec_context).
</para>
<para>
During context establishment, the informational status bits
GSS_S_OLD_TOKEN and GSS_S_DUPLICATE_TOKEN indicate fatal errors, and
GSS-API mechanisms should always return them in association with a
routine error of GSS_S_FAILURE.  This requirement for pairing did not
exist in version 1 of the GSS-API specification, so applications that
wish to run over version 1 implementations must special-case these
codes.
</para>
<para>
The `ret_flags` values:
</para>
<para>
`GSS_C_DELEG_FLAG`::
- True - Delegated credentials are available via the
delegated_cred_handle parameter.
- False - No credentials were delegated.
</para>
<para>
`GSS_C_MUTUAL_FLAG`::
- True - Remote peer asked for mutual authentication.
- False - Remote peer did not ask for mutual authentication.
</para>
<para>
`GSS_C_REPLAY_FLAG`::
- True - replay of protected messages will be detected.
- False - replayed messages will not be detected.
</para>
<para>
`GSS_C_SEQUENCE_FLAG`::
- True - out-of-sequence protected messages will be detected.
- False - out-of-sequence messages will not be detected.
</para>
<para>
`GSS_C_CONF_FLAG`::
- True - Confidentiality service may be invoked by calling the
gss_wrap routine.
- False - No confidentiality service (via gss_wrap)
available. gss_wrap will provide message encapsulation, data-origin
authentication and integrity services only.
</para>
<para>
`GSS_C_INTEG_FLAG`::
- True - Integrity service may be invoked by calling either
gss_get_mic or gss_wrap routines.
- False - Per-message integrity service unavailable.
</para>
<para>
`GSS_C_ANON_FLAG`::
- True - The initiator does not wish to be authenticated; the
src_name parameter (if requested) contains an anonymous internal
name.
- False - The initiator has been authenticated normally.
</para>
<para>
`GSS_C_PROT_READY_FLAG`::
- True - Protection services (as specified by the states of the
GSS_C_CONF_FLAG and GSS_C_INTEG_FLAG) are available if the
accompanying major status return value is either GSS_S_COMPLETE or
GSS_S_CONTINUE_NEEDED.
- False - Protection services (as specified by the states of the
GSS_C_CONF_FLAG and GSS_C_INTEG_FLAG) are available only if the
accompanying major status return value is GSS_S_COMPLETE.
</para>
<para>
`GSS_C_TRANS_FLAG`::
- True - The resultant security context may be transferred to other
processes via a call to <link linkend="gss-export-sec-context"><function>gss_export_sec_context()</function></link>.
- False - The security context is not transferable.
</para>
<para>
All other bits should be set to zero.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_ctx_id_t, read/modify) Context handle for new
  context.  Supply GSS_C_NO_CONTEXT for first call; use value
  returned in subsequent calls.  Once <link linkend="gss-accept-sec-context"><function>gss_accept_sec_context()</function></link> has
  returned a value via this parameter, resources have been assigned
  to the corresponding context, and must be freed by the
  application after use with a call to <link linkend="gss-delete-sec-context"><function>gss_delete_sec_context()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>acceptor_cred_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_cred_id_t, read) Credential handle
  claimed by context acceptor. Specify GSS_C_NO_CREDENTIAL to
  accept the context as a default principal.  If
  GSS_C_NO_CREDENTIAL is specified, but no default acceptor
  principal is defined, GSS_S_NO_CRED will be returned.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>input_token_buffer</parameter>&#160;:</term>
<listitem><simpara>(buffer, opaque, read) Token obtained from
  remote application.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>input_chan_bindings</parameter>&#160;:</term>
<listitem><simpara>(channel bindings, read, optional)
  Application- specified bindings.  Allows application to securely
  bind channel identification information to the security context.
  If channel bindings are not used, specify
  GSS_C_NO_CHANNEL_BINDINGS.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>src_name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, modify, optional) Authenticated name of
  context initiator.  After use, this name should be deallocated by
  passing it to <link linkend="gss-release-name"><function>gss_release_name()</function></link>.  If not required, specify NULL.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mech_type</parameter>&#160;:</term>
<listitem><simpara>(Object ID, modify, optional) Security mechanism used.
  The returned OID value will be a pointer into static storage, and
  should be treated as read-only by the caller (in particular, it
  does not need to be freed).  If not required, specify NULL.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>output_token</parameter>&#160;:</term>
<listitem><simpara>(buffer, opaque, modify) Token to be passed to peer
  application.  If the length field of the returned token buffer is
  0, then no token need be passed to the peer application.  If a
  non- zero length field is returned, the associated storage must
  be freed after use by the application with a call to
  <link linkend="gss-release-buffer"><function>gss_release_buffer()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>ret_flags</parameter>&#160;:</term>
<listitem><simpara>(bit-mask, modify, optional) Contains various
  independent flags, each of which indicates that the context
  supports a specific service option.  If not needed, specify NULL.
  Symbolic names are provided for each flag, and the symbolic names
  corresponding to the required flags should be logically-ANDed
  with the ret_flags value to test whether a given option is
  supported by the context.  See below for the flags.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>time_rec</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify, optional) Number of seconds for which
  the context will remain valid. Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>delegated_cred_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_cred_id_t, modify, optional
  credential) Handle for credentials received from context
  initiator.  Only valid if deleg_flag in ret_flags is true, in
  which case an explicit credential handle (i.e. not
  GSS_C_NO_CREDENTIAL) will be returned; if deleg_flag is false,
  <link linkend="gss-accept-sec-context"><function>gss_accept_sec_context()</function></link> will set this parameter to
  GSS_C_NO_CREDENTIAL.  If a credential handle is returned, the
  associated resources must be released by the application after
  use with a call to <link linkend="gss-release-cred"><function>gss_release_cred()</function></link>.  Specify NULL if not
  required.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_CONTINUE_NEEDED`: Indicates that a token from the peer
application is required to complete the context, and that
gss_accept_sec_context must be called again with that token.

`GSS_S_DEFECTIVE_TOKEN`: Indicates that consistency checks
performed on the input_token failed.

`GSS_S_DEFECTIVE_CREDENTIAL`: Indicates that consistency checks
performed on the credential failed.

`GSS_S_NO_CRED`: The supplied credentials were not valid for
context acceptance, or the credential handle did not reference any
credentials.

`GSS_S_CREDENTIALS_EXPIRED`: The referenced credentials have
expired.

`GSS_S_BAD_BINDINGS`: The input_token contains different channel
bindings to those specified via the input_chan_bindings parameter.

`GSS_S_NO_CONTEXT`: Indicates that the supplied context handle did
not refer to a valid context.

`GSS_S_BAD_SIG`: The input_token contains an invalid MIC.

`GSS_S_OLD_TOKEN`: The input_token was too old.  This is a fatal
error during context establishment.

`GSS_S_DUPLICATE_TOKEN`: The input_token is valid, but is a
duplicate of a token already processed.  This is a fatal error
during context establishment.

`GSS_S_BAD_MECH`: The received token specified a mechanism that is
not supported by the implementation or the provided credential.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-process-context-token" role="function">
<title>gss_process_context_token ()</title>
<indexterm zone="gss-process-context-token"><primary>gss_process_context_token</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_process_context_token           (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> token_buffer</parameter>);</programlisting>
<para>
Provides a way to pass an asynchronous token to the security
service.  Most context-level tokens are emitted and processed
synchronously by gss_init_sec_context and gss_accept_sec_context,
and the application is informed as to whether further tokens are
expected by the GSS_C_CONTINUE_NEEDED major status bit.
Occasionally, a mechanism may need to emit a context-level token at
a point when the peer entity is not expecting a token.  For
example, the initiator's final call to gss_init_sec_context may
emit a token and return a status of GSS_S_COMPLETE, but the
acceptor's call to gss_accept_sec_context may fail.  The acceptor's
mechanism may wish to send a token containing an error indication
to the initiator, but the initiator is not expecting a token at
this point, believing that the context is fully established.
Gss_process_context_token provides a way to pass such a token to
the mechanism at any time.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Implementation specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_ctx_id_t, read) Context handle of context on
  which token is to be processed
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>token_buffer</parameter>&#160;:</term>
<listitem><simpara>(buffer, opaque, read) Token to process.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_DEFECTIVE_TOKEN`: Indicates that consistency checks
performed on the token failed.

`GSS_S_NO_CONTEXT`: The context_handle did not refer to a valid
context.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-delete-sec-context" role="function">
<title>gss_delete_sec_context ()</title>
<indexterm zone="gss-delete-sec-context"><primary>gss_delete_sec_context</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_delete_sec_context              (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> *context_handle</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> output_token</parameter>);</programlisting>
<para>
Delete a security context.  gss_delete_sec_context will delete the
local data structures associated with the specified security
context, and may generate an output_token, which when passed to the
peer gss_process_context_token will instruct it to do likewise.  If
no token is required by the mechanism, the GSS-API should set the
length field of the output_token (if provided) to zero.  No further
security services may be obtained using the context specified by
context_handle.
</para>
<para>
In addition to deleting established security contexts,
gss_delete_sec_context must also be able to delete "half-built"
security contexts resulting from an incomplete sequence of
<link linkend="gss-init-sec-context"><function>gss_init_sec_context()</function></link>/<link linkend="gss-accept-sec-context"><function>gss_accept_sec_context()</function></link> calls.
</para>
<para>
The output_token parameter is retained for compatibility with
version 1 of the GSS-API.  It is recommended that both peer
applications invoke gss_delete_sec_context passing the value
GSS_C_NO_BUFFER for the output_token parameter, indicating that no
token is required, and that gss_delete_sec_context should simply
delete local context data structures.  If the application does pass
a valid buffer to gss_delete_sec_context, mechanisms are encouraged
to return a zero-length token, indicating that no peer action is
necessary, and that no token should be transferred by the
application.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_ctx_id_t, modify) Context handle identifying
  context to delete.  After deleting the context, the GSS-API will
  set this context handle to GSS_C_NO_CONTEXT.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>output_token</parameter>&#160;:</term>
<listitem><simpara>(buffer, opaque, modify, optional) Token to be sent
  to remote application to instruct it to also delete the context.
  It is recommended that applications specify GSS_C_NO_BUFFER for
  this parameter, requesting local deletion only.  If a buffer
  parameter is provided by the application, the mechanism may
  return a token in it; mechanisms that implement only local
  deletion should set the length field of this token to zero to
  indicate to the application that no token is to be sent to the
  peer.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_NO_CONTEXT`: No valid context was supplied.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-context-time" role="function">
<title>gss_context_time ()</title>
<indexterm zone="gss-context-time"><primary>gss_context_time</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_context_time                    (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *time_rec</parameter>);</programlisting>
<para>
Determines the number of seconds for which the specified context
will remain valid.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Implementation specific status
  code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_ctx_id_t, read) Identifies the context to be
  interrogated.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>time_rec</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Number of seconds that the context
  will remain valid.  If the context has already expired, zero will
  be returned.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_CONTEXT_EXPIRED`: The context has already expired.

`GSS_S_NO_CONTEXT`: The context_handle parameter did not identify a
valid context
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-get-mic" role="function">
<title>gss_get_mic ()</title>
<indexterm zone="gss-get-mic"><primary>gss_get_mic</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_get_mic                         (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="gss-qop-t"><type>gss_qop_t</type></link> qop_req</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> message_buffer</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> message_token</parameter>);</programlisting>
<para>
Generates a cryptographic MIC for the supplied message, and places
the MIC in a token for transfer to the peer application. The
qop_req parameter allows a choice between several cryptographic
algorithms, if supported by the chosen mechanism.
</para>
<para>
Since some application-level protocols may wish to use tokens
emitted by <link linkend="gss-wrap"><function>gss_wrap()</function></link> to provide "secure framing", implementations
must support derivation of MICs from zero-length messages.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_ctx_id_t, read) Identifies the context on
  which the message will be sent.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>qop_req</parameter>&#160;:</term>
<listitem><simpara>(gss_qop_t, read, optional) Specifies requested quality
  of protection.  Callers are encouraged, on portability grounds,
  to accept the default quality of protection offered by the chosen
  mechanism, which may be requested by specifying GSS_C_QOP_DEFAULT
  for this parameter.  If an unsupported protection strength is
  requested, gss_get_mic will return a major_status of
  GSS_S_BAD_QOP.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>message_buffer</parameter>&#160;:</term>
<listitem><simpara>(buffer, opaque, read) Message to be protected.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>message_token</parameter>&#160;:</term>
<listitem><simpara>(buffer, opaque, modify) Buffer to receive token.  The
  application must free storage associated with this buffer after
  use with a call to <link linkend="gss-release-buffer"><function>gss_release_buffer()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_CONTEXT_EXPIRED`: The context has already expired.

`GSS_S_NO_CONTEXT`: The context_handle parameter did not identify a
valid context.

`GSS_S_BAD_QOP`: The specified QOP is not supported by the
mechanism.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-verify-mic" role="function">
<title>gss_verify_mic ()</title>
<indexterm zone="gss-verify-mic"><primary>gss_verify_mic</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_verify_mic                      (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> message_buffer</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> token_buffer</parameter>,
                                                         <parameter><link linkend="gss-qop-t"><type>gss_qop_t</type></link> *qop_state</parameter>);</programlisting>
<para>
Verifies that a cryptographic MIC, contained in the token
parameter, fits the supplied message.  The qop_state parameter
allows a message recipient to determine the strength of protection
that was applied to the message.
</para>
<para>
Since some application-level protocols may wish to use tokens
emitted by <link linkend="gss-wrap"><function>gss_wrap()</function></link> to provide "secure framing", implementations
must support the calculation and verification of MICs over
zero-length messages.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_ctx_id_t, read) Identifies the context on
  which the message arrived.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>message_buffer</parameter>&#160;:</term>
<listitem><simpara>(buffer, opaque, read) Message to be verified.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>token_buffer</parameter>&#160;:</term>
<listitem><simpara>(buffer, opaque, read) Token associated with
  message.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>qop_state</parameter>&#160;:</term>
<listitem><simpara>(gss_qop_t, modify, optional) Quality of protection
  gained from MIC Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_DEFECTIVE_TOKEN`: The token failed consistency checks.

`GSS_S_BAD_SIG`: The MIC was incorrect.

`GSS_S_DUPLICATE_TOKEN`: The token was valid, and contained a
correct MIC for the message, but it had already been processed.

`GSS_S_OLD_TOKEN`: The token was valid, and contained a correct MIC
for the message, but it is too old to check for duplication.

`GSS_S_UNSEQ_TOKEN`: The token was valid, and contained a correct
MIC for the message, but has been verified out of sequence; a later
token has already been received.

`GSS_S_GAP_TOKEN`: The token was valid, and contained a correct MIC
for the message, but has been verified out of sequence; an earlier
expected token has not yet been received.

`GSS_S_CONTEXT_EXPIRED`: The context has already expired.

`GSS_S_NO_CONTEXT`: The context_handle parameter did not identify a
valid context.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-wrap" role="function">
<title>gss_wrap ()</title>
<indexterm zone="gss-wrap"><primary>gss_wrap</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_wrap                            (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> conf_req_flag</parameter>,
                                                         <parameter><link linkend="gss-qop-t"><type>gss_qop_t</type></link> qop_req</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> input_message_buffer</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *conf_state</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> output_message_buffer</parameter>);</programlisting>
<para>
Attaches a cryptographic MIC and optionally encrypts the specified
input_message.  The output_message contains both the MIC and the
message.  The qop_req parameter allows a choice between several
cryptographic algorithms, if supported by the chosen mechanism.
</para>
<para>
Since some application-level protocols may wish to use tokens
emitted by <link linkend="gss-wrap"><function>gss_wrap()</function></link> to provide "secure framing", implementations
must support the wrapping of zero-length messages.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_ctx_id_t, read) Identifies the context on
  which the message will be sent.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>conf_req_flag</parameter>&#160;:</term>
<listitem><simpara>(boolean, read) Non-zero - Both confidentiality and
  integrity services are requested. Zero - Only integrity service is
  requested.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>qop_req</parameter>&#160;:</term>
<listitem><simpara>(gss_qop_t, read, optional) Specifies required quality of
  protection.  A mechanism-specific default may be requested by
  setting qop_req to GSS_C_QOP_DEFAULT.  If an unsupported
  protection strength is requested, gss_wrap will return a
  major_status of GSS_S_BAD_QOP.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>input_message_buffer</parameter>&#160;:</term>
<listitem><simpara>(buffer, opaque, read) Message to be
  protected.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>conf_state</parameter>&#160;:</term>
<listitem><simpara>(boolean, modify, optional) Non-zero -
  Confidentiality, data origin authentication and integrity
  services have been applied. Zero - Integrity and data origin
  services only has been applied.  Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>output_message_buffer</parameter>&#160;:</term>
<listitem><simpara>(buffer, opaque, modify) Buffer to receive
  protected message.  Storage associated with this message must be
  freed by the application after use with a call to
  <link linkend="gss-release-buffer"><function>gss_release_buffer()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_CONTEXT_EXPIRED`: The context has already expired.

`GSS_S_NO_CONTEXT`: The context_handle parameter did not identify a
 valid context.

`GSS_S_BAD_QOP`: The specified QOP is not supported by the
mechanism.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-unwrap" role="function">
<title>gss_unwrap ()</title>
<indexterm zone="gss-unwrap"><primary>gss_unwrap</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_unwrap                          (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> input_message_buffer</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> output_message_buffer</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *conf_state</parameter>,
                                                         <parameter><link linkend="gss-qop-t"><type>gss_qop_t</type></link> *qop_state</parameter>);</programlisting>
<para>
Converts a message previously protected by gss_wrap back to a
usable form, verifying the embedded MIC.  The conf_state parameter
indicates whether the message was encrypted; the qop_state
parameter indicates the strength of protection that was used to
provide the confidentiality and integrity services.
</para>
<para>
Since some application-level protocols may wish to use tokens
emitted by <link linkend="gss-wrap"><function>gss_wrap()</function></link> to provide "secure framing", implementations
must support the wrapping and unwrapping of zero-length messages.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_ctx_id_t, read) Identifies the context on
  which the message arrived.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>input_message_buffer</parameter>&#160;:</term>
<listitem><simpara>(buffer, opaque, read) Protected message.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>output_message_buffer</parameter>&#160;:</term>
<listitem><simpara>(buffer, opaque, modify) Buffer to receive
  unwrapped message.  Storage associated with this buffer must be
  freed by the application after use use with a call to
  <link linkend="gss-release-buffer"><function>gss_release_buffer()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>conf_state</parameter>&#160;:</term>
<listitem><simpara>(boolean, modify, optional) Non-zero - Confidentiality
  and integrity protection were used. Zero - Integrity service only
  was used.  Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>qop_state</parameter>&#160;:</term>
<listitem><simpara>(gss_qop_t, modify, optional) Quality of protection
  provided.  Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_DEFECTIVE_TOKEN`: The token failed consistency checks.

`GSS_S_BAD_SIG`: The MIC was incorrect.

`GSS_S_DUPLICATE_TOKEN`: The token was valid, and contained a
 correct MIC for the message, but it had already been processed.

`GSS_S_OLD_TOKEN`: The token was valid, and contained a correct MIC
for the message, but it is too old to check for duplication.

`GSS_S_UNSEQ_TOKEN`: The token was valid, and contained a correct
MIC for the message, but has been verified out of sequence; a later
token has already been received.

`GSS_S_GAP_TOKEN`: The token was valid, and contained a correct MIC
for the message, but has been verified out of sequence; an earlier
expected token has not yet been received.

`GSS_S_CONTEXT_EXPIRED`: The context has already expired.

`GSS_S_NO_CONTEXT`: The context_handle parameter did not identify a
valid context.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-display-status" role="function">
<title>gss_display_status ()</title>
<indexterm zone="gss-display-status"><primary>gss_display_status</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_display_status                  (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> status_value</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> status_type</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> mech_type</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *message_context</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> status_string</parameter>);</programlisting>
<para>
Allows an application to obtain a textual representation of a
GSS-API status code, for display to the user or for logging
purposes.  Since some status values may indicate multiple
conditions, applications may need to call gss_display_status
multiple times, each call generating a single text string.  The
message_context parameter is used by gss_display_status to store
state information about which error messages have already been
extracted from a given status_value; message_context must be
initialized to 0 by the application prior to the first call, and
gss_display_status will return a non-zero value in this parameter
if there are further messages to extract.
</para>
<para>
The message_context parameter contains all state information
required by gss_display_status in order to extract further messages
from the status_value; even when a non-zero value is returned in
this parameter, the application is not required to call
gss_display_status again unless subsequent messages are desired.
The following code extracts all messages from a given status code
and prints them to stderr:
</para>
<para>
---------------------------------------------------
OM_uint32 message_context;
OM_uint32 status_code;
OM_uint32 maj_status;
OM_uint32 min_status;
gss_buffer_desc status_string;
</para>
<para>
       ...
</para>
<para>
message_context = 0;
</para>
<para>
do {
  maj_status = gss_display_status (
                  &amp;min_status,
                  status_code,
                  GSS_C_GSS_CODE,
                  GSS_C_NO_OID,
                  &amp;message_context,
                  &amp;status_string)
</para>
<para>
  fprintf(stderr,
          "%.*s\n",
         (int)status_string.length,
</para>
<para>
         (char *)status_string.value);
</para>
<para>
  gss_release_buffer(&amp;min_status, &amp;status_string);
</para>
<para>
} while (message_context != 0);
---------------------------------------------------</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>status_value</parameter>&#160;:</term>
<listitem><simpara>(Integer, read) Status value to be converted.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>status_type</parameter>&#160;:</term>
<listitem><simpara>(Integer, read) GSS_C_GSS_CODE - status_value is a
  GSS status code. GSS_C_MECH_CODE - status_value is a mechanism
  status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mech_type</parameter>&#160;:</term>
<listitem><simpara>(Object ID, read, optional) Underlying mechanism (used
  to interpret a minor status value). Supply GSS_C_NO_OID to obtain
  the system default.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>message_context</parameter>&#160;:</term>
<listitem><simpara>(Integer, read/modify) Should be initialized to
  zero by the application prior to the first call.  On return from
  <link linkend="gss-display-status"><function>gss_display_status()</function></link>, a non-zero status_value parameter indicates
  that additional messages may be extracted from the status code
  via subsequent calls to <link linkend="gss-display-status"><function>gss_display_status()</function></link>, passing the same
  status_value, status_type, mech_type, and message_context
  parameters.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>status_string</parameter>&#160;:</term>
<listitem><simpara>(buffer, character string, modify) Textual
  interpretation of the status_value.  Storage associated with this
  parameter must be freed by the application after use with a call
  to <link linkend="gss-release-buffer"><function>gss_release_buffer()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_BAD_MECH`: Indicates that translation in accordance with an
unsupported mechanism type was requested.

`GSS_S_BAD_STATUS`: The status value was not recognized, or the
status type was neither GSS_C_GSS_CODE nor GSS_C_MECH_CODE.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-indicate-mechs" role="function">
<title>gss_indicate_mechs ()</title>
<indexterm zone="gss-indicate-mechs"><primary>gss_indicate_mechs</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_indicate_mechs                  (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *mech_set</parameter>);</programlisting>
<para>
Allows an application to determine which underlying security
mechanisms are available.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mech_set</parameter>&#160;:</term>
<listitem><simpara>(set of Object IDs, modify) Set of
  implementation-supported mechanisms.  The returned gss_OID_set
  value will be a dynamically-allocated OID set, that should be
  released by the caller after use with a call to
  <link linkend="gss-release-oid-set"><function>gss_release_oid_set()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-compare-name" role="function">
<title>gss_compare_name ()</title>
<indexterm zone="gss-compare-name"><primary>gss_compare_name</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_compare_name                    (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> name1</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> name2</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *name_equal</parameter>);</programlisting>
<para>
Allows an application to compare two internal-form names to
determine whether they refer to the same entity.
</para>
<para>
If either name presented to gss_compare_name denotes an anonymous
principal, the routines should indicate that the two names do not
refer to the same identity.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>name1</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, read) Internal-form name.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>name2</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, read) Internal-form name.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>name_equal</parameter>&#160;:</term>
<listitem><simpara>(boolean, modify) Non-zero - names refer to same
  entity. Zero - names refer to different entities (strictly, the
  names are not known to refer to the same identity).
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_BAD_NAMETYPE`: The two names were of incomparable types.

`GSS_S_BAD_NAME`: One or both of name1 or name2 was ill-formed.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-display-name" role="function">
<title>gss_display_name ()</title>
<indexterm zone="gss-display-name"><primary>gss_display_name</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_display_name                    (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> input_name</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> output_name_buffer</parameter>,
                                                         <parameter><link linkend="gss-OID"><type>gss_OID</type></link> *output_name_type</parameter>);</programlisting>
<para>
Allows an application to obtain a textual representation of an
opaque internal-form name for display purposes.  The syntax of a
printable name is defined by the GSS-API implementation.
</para>
<para>
If input_name denotes an anonymous principal, the implementation
should return the gss_OID value GSS_C_NT_ANONYMOUS as the
output_name_type, and a textual name that is syntactically distinct
from all valid supported printable names in output_name_buffer.
</para>
<para>
If input_name was created by a call to gss_import_name, specifying
GSS_C_NO_OID as the name-type, implementations that employ lazy
conversion between name types may return GSS_C_NO_OID via the
output_name_type parameter.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>input_name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, read) Name to be displayed.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>output_name_buffer</parameter>&#160;:</term>
<listitem><simpara>(buffer, character-string, modify) Buffer to
  receive textual name string.  The application must free storage
  associated with this name after use with a call to
  <link linkend="gss-release-buffer"><function>gss_release_buffer()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>output_name_type</parameter>&#160;:</term>
<listitem><simpara>(Object ID, modify, optional) The type of the
  returned name.  The returned gss_OID will be a pointer into
  static storage, and should be treated as read-only by the caller
  (in particular, the application should not attempt to free
  it). Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_BAD_NAME`: <parameter>input_name</parameter> was ill-formed.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-import-name" role="function">
<title>gss_import_name ()</title>
<indexterm zone="gss-import-name"><primary>gss_import_name</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_import_name                     (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> input_name_buffer</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> input_name_type</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *output_name</parameter>);</programlisting>
<para>
Convert a contiguous string name to internal form.  In general, the
internal name returned (via the <parameter>output_name</parameter> parameter) will not
be an MN; the exception to this is if the <parameter>input_name_type</parameter>
indicates that the contiguous string provided via the
<parameter>input_name_buffer</parameter> parameter is of type GSS_C_NT_EXPORT_NAME, in
which case the returned internal name will be an MN for the
mechanism that exported the name.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>input_name_buffer</parameter>&#160;:</term>
<listitem><simpara>(buffer, octet-string, read) Buffer containing
  contiguous string name to convert.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>input_name_type</parameter>&#160;:</term>
<listitem><simpara>(Object ID, read, optional) Object ID specifying
  type of printable name.  Applications may specify either
  GSS_C_NO_OID to use a mechanism-specific default printable
  syntax, or an OID recognized by the GSS-API implementation to
  name a specific namespace.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>output_name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, modify) Returned name in internal form.
  Storage associated with this name must be freed by the
  application after use with a call to <link linkend="gss-release-name"><function>gss_release_name()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_BAD_NAMETYPE`: The input_name_type was unrecognized.

`GSS_S_BAD_NAME`: The input_name parameter could not be interpreted
as a name of the specified type.

`GSS_S_BAD_MECH`: The input name-type was GSS_C_NT_EXPORT_NAME, but
the mechanism contained within the input-name is not supported.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-export-name" role="function">
<title>gss_export_name ()</title>
<indexterm zone="gss-export-name"><primary>gss_export_name</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_export_name                     (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> input_name</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> exported_name</parameter>);</programlisting>
<para>
To produce a canonical contiguous string representation of a
mechanism name (MN), suitable for direct comparison (e.g. with
memcmp) for use in authorization functions (e.g. matching entries
in an access-control list).  The <parameter>input_name</parameter> parameter must specify
a valid MN (i.e. an internal name generated by
<link linkend="gss-accept-sec-context"><function>gss_accept_sec_context()</function></link> or by <link linkend="gss-canonicalize-name"><function>gss_canonicalize_name()</function></link>).</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>input_name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, read) The MN to be exported.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>exported_name</parameter>&#160;:</term>
<listitem><simpara>(gss_buffer_t, octet-string, modify) The canonical
  contiguous string form of <parameter>input_name</parameter>.  Storage associated with
  this string must freed by the application after use with
  <link linkend="gss-release-buffer"><function>gss_release_buffer()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_NAME_NOT_MN`: The provided internal name was not a mechanism
name.

`GSS_S_BAD_NAME`: The provided internal name was ill-formed.

`GSS_S_BAD_NAMETYPE`: The internal name was of a type not supported
by the GSS-API implementation.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-release-name" role="function">
<title>gss_release_name ()</title>
<indexterm zone="gss-release-name"><primary>gss_release_name</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_release_name                    (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *name</parameter>);</programlisting>
<para>
Free GSSAPI-allocated storage associated with an internal-form
name.  The name is set to GSS_C_NO_NAME on successful completion of
this call.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, modify) The name to be deleted.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_BAD_NAME`: The name parameter did not contain a valid name.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-release-buffer" role="function">
<title>gss_release_buffer ()</title>
<indexterm zone="gss-release-buffer"><primary>gss_release_buffer</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_release_buffer                  (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> buffer</parameter>);</programlisting>
<para>
Free storage associated with a buffer.  The storage must have been
allocated by a GSS-API routine.  In addition to freeing the
associated storage, the routine will zero the length field in the
descriptor to which the buffer parameter refers, and
implementations are encouraged to additionally set the pointer
field in the descriptor to NULL.  Any buffer object returned by a
GSS-API routine may be passed to gss_release_buffer (even if there
is no storage associated with the buffer).</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>buffer</parameter>&#160;:</term>
<listitem><simpara>(buffer, modify) The storage associated with the buffer
  will be deleted.  The gss_buffer_desc object will not be freed,
  but its length field will be zeroed.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-release-oid-set" role="function">
<title>gss_release_oid_set ()</title>
<indexterm zone="gss-release-oid-set"><primary>gss_release_oid_set</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_release_oid_set                 (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *set</parameter>);</programlisting>
<para>
Free storage associated with a GSSAPI-generated gss_OID_set object.
The set parameter must refer to an OID-set that was returned from a
GSS-API routine.  <link linkend="gss-release-oid-set"><function>gss_release_oid_set()</function></link> will free the storage
associated with each individual member OID, the OID set's elements
array, and the gss_OID_set_desc.
</para>
<para>
The gss_OID_set parameter is set to GSS_C_NO_OID_SET on successful
completion of this routine.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>set</parameter>&#160;:</term>
<listitem><simpara>(Set of Object IDs, modify) The storage associated with the
  gss_OID_set will be deleted.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-inquire-cred" role="function">
<title>gss_inquire_cred ()</title>
<indexterm zone="gss-inquire-cred"><primary>gss_inquire_cred</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_inquire_cred                    (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> cred_handle</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *name</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *lifetime</parameter>,
                                                         <parameter><link linkend="gss-cred-usage-t"><type>gss_cred_usage_t</type></link> *cred_usage</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *mechanisms</parameter>);</programlisting>
<para>
Obtains information about a credential.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>cred_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_cred_id_t, read) A handle that refers to the
  target credential.  Specify GSS_C_NO_CREDENTIAL to inquire about
  the default initiator principal.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, modify, optional) The name whose identity the
  credential asserts.  Storage associated with this name should be
  freed by the application after use with a call to
  <link linkend="gss-release-name"><function>gss_release_name()</function></link>.  Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>lifetime</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify, optional) The number of seconds for
  which the credential will remain valid.  If the credential has
  expired, this parameter will be set to zero.  If the
  implementation does not support credential expiration, the value
  GSS_C_INDEFINITE will be returned.  Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>cred_usage</parameter>&#160;:</term>
<listitem><simpara>(gss_cred_usage_t, modify, optional) How the
  credential may be used.  One of the following: GSS_C_INITIATE,
  GSS_C_ACCEPT, GSS_C_BOTH. Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mechanisms</parameter>&#160;:</term>
<listitem><simpara>(gss_OID_set, modify, optional) Set of mechanisms
  supported by the credential.  Storage associated with this OID
  set must be freed by the application after use with a call to
  <link linkend="gss-release-oid-set"><function>gss_release_oid_set()</function></link>.  Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_NO_CRED`: The referenced credentials could not be accessed.

`GSS_S_DEFECTIVE_CREDENTIAL`: The referenced credentials were invalid.

`GSS_S_CREDENTIALS_EXPIRED`: The referenced credentials have
expired.  If the lifetime parameter was not passed as NULL, it will
be set to 0.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-inquire-context" role="function">
<title>gss_inquire_context ()</title>
<indexterm zone="gss-inquire-context"><primary>gss_inquire_context</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_inquire_context                 (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *src_name</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *targ_name</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *lifetime_rec</parameter>,
                                                         <parameter><link linkend="gss-OID"><type>gss_OID</type></link> *mech_type</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *ctx_flags</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *locally_initiated</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *open</parameter>);</programlisting>
<para>
Obtains information about a security context.  The caller must
already have obtained a handle that refers to the context, although
the context need not be fully established.
</para>
<para>
The `ctx_flags` values:
</para>
<para>
`GSS_C_DELEG_FLAG`::
- True - Credentials were delegated from the initiator to the
acceptor.
- False - No credentials were delegated.
</para>
<para>
`GSS_C_MUTUAL_FLAG`::
- True - The acceptor was authenticated to the initiator.
- False - The acceptor did not authenticate itself.
</para>
<para>
`GSS_C_REPLAY_FLAG`::
- True - replay of protected messages will be detected.
- False - replayed messages will not be detected.
</para>
<para>
`GSS_C_SEQUENCE_FLAG`::
- True - out-of-sequence protected messages will be detected.
- False - out-of-sequence messages will not be detected.
</para>
<para>
`GSS_C_CONF_FLAG`::
- True - Confidentiality service may be invoked by calling gss_wrap
routine.
- False - No confidentiality service (via gss_wrap)
available. gss_wrap will provide message encapsulation, data-origin
authentication and integrity services only.
</para>
<para>
`GSS_C_INTEG_FLAG`::
- True - Integrity service may be invoked by calling either
gss_get_mic or gss_wrap routines.
- False - Per-message integrity service unavailable.
</para>
<para>
`GSS_C_ANON_FLAG`::
- True - The initiator's identity will not be revealed to the
acceptor.  The src_name parameter (if requested) contains an
anonymous internal name.
- False - The initiator has been authenticated normally.
</para>
<para>
`GSS_C_PROT_READY_FLAG`::
- True - Protection services (as specified by the states of the
GSS_C_CONF_FLAG and GSS_C_INTEG_FLAG) are available for use.
- False - Protection services (as specified by the states of the
GSS_C_CONF_FLAG and GSS_C_INTEG_FLAG) are available only if the
context is fully established (i.e. if the open parameter is
non-zero).
</para>
<para>
`GSS_C_TRANS_FLAG`::
- True - The resultant security context may be transferred to other
processes via a call to <link linkend="gss-export-sec-context"><function>gss_export_sec_context()</function></link>.
- False - The security context is not transferable.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_ctx_id_t, read) A handle that refers to the
  security context.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>src_name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, modify, optional) The name of the context
  initiator.  If the context was established using anonymous
  authentication, and if the application invoking
  gss_inquire_context is the context acceptor, an anonymous name
  will be returned.  Storage associated with this name must be
  freed by the application after use with a call to
  <link linkend="gss-release-name"><function>gss_release_name()</function></link>.  Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>targ_name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, modify, optional) The name of the context
  acceptor.  Storage associated with this name must be freed by the
  application after use with a call to <link linkend="gss-release-name"><function>gss_release_name()</function></link>.  If the
  context acceptor did not authenticate itself, and if the
  initiator did not specify a target name in its call to
  <link linkend="gss-init-sec-context"><function>gss_init_sec_context()</function></link>, the value GSS_C_NO_NAME will be returned.
  Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>lifetime_rec</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify, optional) The number of seconds
  for which the context will remain valid.  If the context has
  expired, this parameter will be set to zero.  If the
  implementation does not support context expiration, the value
  GSS_C_INDEFINITE will be returned.  Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mech_type</parameter>&#160;:</term>
<listitem><simpara>(gss_OID, modify, optional) The security mechanism
  providing the context.  The returned OID will be a pointer to
  static storage that should be treated as read-only by the
  application; in particular the application should not attempt to
  free it.  Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>ctx_flags</parameter>&#160;:</term>
<listitem><simpara>(bit-mask, modify, optional) Contains various
  independent flags, each of which indicates that the context
  supports (or is expected to support, if ctx_open is false) a
  specific service option.  If not needed, specify NULL.  Symbolic
  names are provided for each flag, and the symbolic names
  corresponding to the required flags should be logically-ANDed
  with the ret_flags value to test whether a given option is
  supported by the context.  See below for the flags.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>locally_initiated</parameter>&#160;:</term>
<listitem><simpara>(Boolean, modify) Non-zero if the invoking
  application is the context initiator.  Specify NULL if not
  required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>open</parameter>&#160;:</term>
<listitem><simpara>(Boolean, modify) Non-zero if the context is fully
  established; Zero if a context-establishment token is expected
  from the peer application.  Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_NO_CONTEXT`: The referenced context could not be accessed.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-wrap-size-limit" role="function">
<title>gss_wrap_size_limit ()</title>
<indexterm zone="gss-wrap-size-limit"><primary>gss_wrap_size_limit</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_wrap_size_limit                 (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> conf_req_flag</parameter>,
                                                         <parameter><link linkend="gss-qop-t"><type>gss_qop_t</type></link> qop_req</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> req_output_size</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *max_input_size</parameter>);</programlisting>
<para>
Allows an application to determine the maximum message size that,
if presented to gss_wrap with the same conf_req_flag and qop_req
parameters, will result in an output token containing no more than
req_output_size bytes.
</para>
<para>
This call is intended for use by applications that communicate over
protocols that impose a maximum message size.  It enables the
application to fragment messages prior to applying protection.
</para>
<para>
GSS-API implementations are recommended but not required to detect
invalid QOP values when <link linkend="gss-wrap-size-limit"><function>gss_wrap_size_limit()</function></link> is called. This
routine guarantees only a maximum message size, not the
availability of specific QOP values for message protection.
</para>
<para>
Successful completion of this call does not guarantee that gss_wrap
will be able to protect a message of length max_input_size bytes,
since this ability may depend on the availability of system
resources at the time that gss_wrap is called.  However, if the
implementation itself imposes an upper limit on the length of
messages that may be processed by gss_wrap, the implementation
should not return a value via max_input_bytes that is greater than
this length.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_ctx_id_t, read) A handle that refers to the
  security over which the messages will be sent.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>conf_req_flag</parameter>&#160;:</term>
<listitem><simpara>(Boolean, read) Indicates whether gss_wrap will be
  asked to apply confidentiality protection in addition to
  integrity protection.  See the routine description for gss_wrap
  for more details.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>qop_req</parameter>&#160;:</term>
<listitem><simpara>(gss_qop_t, read) Indicates the level of protection that
  gss_wrap will be asked to provide.  See the routine description
  for gss_wrap for more details.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>req_output_size</parameter>&#160;:</term>
<listitem><simpara>(Integer, read) The desired maximum size for
  tokens emitted by gss_wrap.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>max_input_size</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) The maximum input message size
  that may be presented to gss_wrap in order to guarantee that the
  emitted token shall be no larger than req_output_size bytes.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_NO_CONTEXT`: The referenced context could not be accessed.

`GSS_S_CONTEXT_EXPIRED`: The context has expired.

`GSS_S_BAD_QOP`: The specified QOP is not supported by the
mechanism.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-add-cred" role="function">
<title>gss_add_cred ()</title>
<indexterm zone="gss-add-cred"><primary>gss_add_cred</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_add_cred                        (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> input_cred_handle</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> desired_name</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> desired_mech</parameter>,
                                                         <parameter><link linkend="gss-cred-usage-t"><type>gss_cred_usage_t</type></link> cred_usage</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> initiator_time_req</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> acceptor_time_req</parameter>,
                                                         <parameter><link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> *output_cred_handle</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *actual_mechs</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *initiator_time_rec</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *acceptor_time_rec</parameter>);</programlisting>
<para>
Adds a credential-element to a credential.  The credential-element is
identified by the name of the principal to which it refers.  GSS-API
implementations must impose a local access-control policy on callers
of this routine to prevent unauthorized callers from acquiring
credential-elements to which they are not entitled. This routine is
not intended to provide a "login to the network" function, as such a
function would involve the creation of new mechanism-specific
authentication data, rather than merely acquiring a GSS-API handle to
existing data.  Such functions, if required, should be defined in
implementation-specific extensions to the API.
</para>
<para>
If desired_name is GSS_C_NO_NAME, the call is interpreted as a
request to add a credential element that will invoke default behavior
when passed to <link linkend="gss-init-sec-context"><function>gss_init_sec_context()</function></link> (if cred_usage is
GSS_C_INITIATE or GSS_C_BOTH) or <link linkend="gss-accept-sec-context"><function>gss_accept_sec_context()</function></link> (if
cred_usage is GSS_C_ACCEPT or GSS_C_BOTH).
</para>
<para>
This routine is expected to be used primarily by context acceptors,
since implementations are likely to provide mechanism-specific ways
of obtaining GSS-API initiator credentials from the system login
process.  Some implementations may therefore not support the
acquisition of GSS_C_INITIATE or GSS_C_BOTH credentials via
gss_acquire_cred for any name other than GSS_C_NO_NAME, or a name
produced by applying either gss_inquire_cred to a valid credential,
or gss_inquire_context to an active context.
</para>
<para>
If credential acquisition is time-consuming for a mechanism, the
mechanism may choose to delay the actual acquisition until the
credential is required (e.g. by gss_init_sec_context or
gss_accept_sec_context).  Such mechanism-specific implementation
decisions should be invisible to the calling application; thus a call
of gss_inquire_cred immediately following the call of gss_add_cred
must return valid credential data, and may therefore incur the
overhead of a deferred credential acquisition.
</para>
<para>
This routine can be used to either compose a new credential
containing all credential-elements of the original in addition to the
newly-acquire credential-element, or to add the new credential-
element to an existing credential. If NULL is specified for the
output_cred_handle parameter argument, the new credential-element
will be added to the credential identified by input_cred_handle; if a
valid pointer is specified for the output_cred_handle parameter, a
new credential handle will be created.
</para>
<para>
If GSS_C_NO_CREDENTIAL is specified as the input_cred_handle,
gss_add_cred will compose a credential (and set the
output_cred_handle parameter accordingly) based on default behavior.
That is, the call will have the same effect as if the application had
first made a call to <link linkend="gss-acquire-cred"><function>gss_acquire_cred()</function></link>, specifying the same usage
and passing GSS_C_NO_NAME as the desired_name parameter to obtain an
explicit credential handle embodying default behavior, passed this
credential handle to <link linkend="gss-add-cred"><function>gss_add_cred()</function></link>, and finally called
<link linkend="gss-release-cred"><function>gss_release_cred()</function></link> on the first credential handle.
</para>
<para>
If GSS_C_NO_CREDENTIAL is specified as the input_cred_handle
parameter, a non-NULL output_cred_handle must be supplied.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>input_cred_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_cred_id_t, read, optional) The credential
  to which a credential-element will be added.  If
  GSS_C_NO_CREDENTIAL is specified, the routine will compose the
  new credential based on default behavior (see text).
  Note that, while the credential-handle is not modified by
  <link linkend="gss-add-cred"><function>gss_add_cred()</function></link>, the underlying credential will be modified if
  output_credential_handle is NULL.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>desired_name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, read.)  Name of principal whose
  credential should be acquired.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>desired_mech</parameter>&#160;:</term>
<listitem><simpara>(Object ID, read) Underlying security mechanism with
  which the credential may be used.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>cred_usage</parameter>&#160;:</term>
<listitem><simpara>(gss_cred_usage_t, read) GSS_C_BOTH - Credential may
  be used either to initiate or accept security contexts.
  GSS_C_INITIATE - Credential will only be used to initiate
  security contexts.  GSS_C_ACCEPT - Credential will only be used
  to accept security contexts.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>initiator_time_req</parameter>&#160;:</term>
<listitem><simpara>(Integer, read, optional) number of seconds
  that the credential should remain valid for initiating security
  contexts.  This argument is ignored if the composed credentials
  are of type GSS_C_ACCEPT.  Specify GSS_C_INDEFINITE to request
  that the credentials have the maximum permitted initiator
  lifetime.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>acceptor_time_req</parameter>&#160;:</term>
<listitem><simpara>(Integer, read, optional) number of seconds
  that the credential should remain valid for accepting security
  contexts.  This argument is ignored if the composed credentials
  are of type GSS_C_INITIATE.  Specify GSS_C_INDEFINITE to request
  that the credentials have the maximum permitted initiator
  lifetime.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>output_cred_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_cred_id_t, modify, optional) The returned
  credential handle, containing the new credential-element and all
  the credential-elements from input_cred_handle.  If a valid
  pointer to a gss_cred_id_t is supplied for this parameter,
  gss_add_cred creates a new credential handle containing all
  credential-elements from the input_cred_handle and the newly
  acquired credential-element; if NULL is specified for this
  parameter, the newly acquired credential-element will be added to
  the credential identified by input_cred_handle.  The resources
  associated with any credential handle returned via this parameter
  must be released by the application after use with a call to
  <link linkend="gss-release-cred"><function>gss_release_cred()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>actual_mechs</parameter>&#160;:</term>
<listitem><simpara>(Set of Object IDs, modify, optional) The complete
  set of mechanisms for which the new credential is valid.  Storage
  for the returned OID-set must be freed by the application after
  use with a call to <link linkend="gss-release-oid-set"><function>gss_release_oid_set()</function></link>. Specify NULL if not
  required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>initiator_time_rec</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify, optional) Actual number of
  seconds for which the returned credentials will remain valid for
  initiating contexts using the specified mechanism.  If the
  implementation or mechanism does not support expiration of
  credentials, the value GSS_C_INDEFINITE will be returned. Specify
  NULL if not required
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>acceptor_time_rec</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify, optional) Actual number of
  seconds for which the returned credentials will remain valid for
  accepting security contexts using the specified mechanism.  If
  the implementation or mechanism does not support expiration of
  credentials, the value GSS_C_INDEFINITE will be returned. Specify
  NULL if not required
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_BAD_MECH`: Unavailable mechanism requested.

`GSS_S_BAD_NAMETYPE`: Type contained within desired_name parameter
is not supported.

`GSS_S_BAD_NAME`: Value supplied for desired_name parameter is
ill-formed.

`GSS_S_DUPLICATE_ELEMENT`: The credential already contains an
element for the requested mechanism with overlapping usage and
validity period.

`GSS_S_CREDENTIALS_EXPIRED`: The required credentials could not be
added because they have expired.

`GSS_S_NO_CRED`: No credentials were found for the specified name.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-inquire-cred-by-mech" role="function">
<title>gss_inquire_cred_by_mech ()</title>
<indexterm zone="gss-inquire-cred-by-mech"><primary>gss_inquire_cred_by_mech</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_inquire_cred_by_mech            (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-cred-id-t"><type>gss_cred_id_t</type></link> cred_handle</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> mech_type</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *name</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *initiator_lifetime</parameter>,
                                                         <parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *acceptor_lifetime</parameter>,
                                                         <parameter><link linkend="gss-cred-usage-t"><type>gss_cred_usage_t</type></link> *cred_usage</parameter>);</programlisting>
<para>
Obtains per-mechanism information about a credential.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>cred_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_cred_id_t, read) A handle that refers to the
  target credential.  Specify GSS_C_NO_CREDENTIAL to inquire about
  the default initiator principal.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mech_type</parameter>&#160;:</term>
<listitem><simpara>(gss_OID, read) The mechanism for which information
 should be returned.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, modify, optional) The name whose identity the
  credential asserts.  Storage associated with this name must be
  freed by the application after use with a call to
  <link linkend="gss-release-name"><function>gss_release_name()</function></link>.  Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>initiator_lifetime</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify, optional) The number of
  seconds for which the credential will remain capable of
  initiating security contexts under the specified mechanism.  If
  the credential can no longer be used to initiate contexts, or if
  the credential usage for this mechanism is GSS_C_ACCEPT, this
  parameter will be set to zero.  If the implementation does not
  support expiration of initiator credentials, the value
  GSS_C_INDEFINITE will be returned.  Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>acceptor_lifetime</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify, optional) The number of
  seconds for which the credential will remain capable of accepting
  security contexts under the specified mechanism.  If the
  credential can no longer be used to accept contexts, or if the
  credential usage for this mechanism is GSS_C_INITIATE, this
  parameter will be set to zero.  If the implementation does not
  support expiration of acceptor credentials, the value
  GSS_C_INDEFINITE will be returned.  Specify NULL if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>cred_usage</parameter>&#160;:</term>
<listitem><simpara>(gss_cred_usage_t, modify, optional) How the
  credential may be used with the specified mechanism.  One of the
  following: GSS_C_INITIATE, GSS_C_ACCEPT, GSS_C_BOTH. Specify NULL
  if not required.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_NO_CRED`: The referenced credentials could not be accessed.

`GSS_S_DEFECTIVE_CREDENTIAL`: The referenced credentials were invalid.

`GSS_S_CREDENTIALS_EXPIRED`: The referenced credentials have
expired.  If the lifetime parameter was not passed as NULL, it will
be set to 0.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-export-sec-context" role="function">
<title>gss_export_sec_context ()</title>
<indexterm zone="gss-export-sec-context"><primary>gss_export_sec_context</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_export_sec_context              (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> *context_handle</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> interprocess_token</parameter>);</programlisting>
<para>
Provided to support the sharing of work between multiple processes.
This routine will typically be used by the context-acceptor, in an
application where a single process receives incoming connection
requests and accepts security contexts over them, then passes the
established context to one or more other processes for message
exchange. <link linkend="gss-export-sec-context"><function>gss_export_sec_context()</function></link> deactivates the security context
for the calling process and creates an interprocess token which,
when passed to gss_import_sec_context in another process, will
re-activate the context in the second process. Only a single
instantiation of a given context may be active at any one time; a
subsequent attempt by a context exporter to access the exported
security context will fail.
</para>
<para>
The implementation may constrain the set of processes by which the
interprocess token may be imported, either as a function of local
security policy, or as a result of implementation decisions.  For
example, some implementations may constrain contexts to be passed
only between processes that run under the same account, or which
are part of the same process group.
</para>
<para>
The interprocess token may contain security-sensitive information
(for example cryptographic keys).  While mechanisms are encouraged
to either avoid placing such sensitive information within
interprocess tokens, or to encrypt the token before returning it to
the application, in a typical object-library GSS-API implementation
this may not be possible. Thus the application must take care to
protect the interprocess token, and ensure that any process to
which the token is transferred is trustworthy.
</para>
<para>
If creation of the interprocess token is successful, the
implementation shall deallocate all process-wide resources
associated with the security context, and set the context_handle to
GSS_C_NO_CONTEXT.  In the event of an error that makes it
impossible to complete the export of the security context, the
implementation must not return an interprocess token, and should
strive to leave the security context referenced by the
context_handle parameter untouched.  If this is impossible, it is
permissible for the implementation to delete the security context,
providing it also sets the context_handle parameter to
GSS_C_NO_CONTEXT.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_ctx_id_t, modify) Context handle identifying
  the context to transfer.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>interprocess_token</parameter>&#160;:</term>
<listitem><simpara>(buffer, opaque, modify) Token to be
  transferred to target process.  Storage associated with this
  token must be freed by the application after use with a call to
  <link linkend="gss-release-buffer"><function>gss_release_buffer()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_CONTEXT_EXPIRED`: The context has expired.

`GSS_S_NO_CONTEXT`: The context was invalid.

`GSS_S_UNAVAILABLE`: The operation is not supported.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-import-sec-context" role="function">
<title>gss_import_sec_context ()</title>
<indexterm zone="gss-import-sec-context"><primary>gss_import_sec_context</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_import_sec_context              (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> interprocess_token</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> *context_handle</parameter>);</programlisting>
<para>
Allows a process to import a security context established by
another process.  A given interprocess token may be imported only
once.  See gss_export_sec_context.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>interprocess_token</parameter>&#160;:</term>
<listitem><simpara>(buffer, opaque, modify) Token received from
  exporting process
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>(gss_ctx_id_t, modify) Context handle of newly
  reactivated context.  Resources associated with this context
  handle must be released by the application after use with a call
  to <link linkend="gss-delete-sec-context"><function>gss_delete_sec_context()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_NO_CONTEXT`: The token did not contain a valid context
reference.

`GSS_S_DEFECTIVE_TOKEN`: The token was invalid.

`GSS_S_UNAVAILABLE`: The operation is unavailable.

`GSS_S_UNAUTHORIZED`: Local policy prevents the import of this
 context by the current process.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-create-empty-oid-set" role="function">
<title>gss_create_empty_oid_set ()</title>
<indexterm zone="gss-create-empty-oid-set"><primary>gss_create_empty_oid_set</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_create_empty_oid_set            (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *oid_set</parameter>);</programlisting>
<para>
Create an object-identifier set containing no object identifiers,
to which members may be subsequently added using the
<link linkend="gss-add-oid-set-member"><function>gss_add_oid_set_member()</function></link> routine.  These routines are intended to
be used to construct sets of mechanism object identifiers, for
input to gss_acquire_cred.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>oid_set</parameter>&#160;:</term>
<listitem><simpara>(Set of Object IDs, modify) The empty object identifier
  set.  The routine will allocate the gss_OID_set_desc object,
  which the application must free after use with a call to
  <link linkend="gss-release-oid-set"><function>gss_release_oid_set()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-add-oid-set-member" role="function">
<title>gss_add_oid_set_member ()</title>
<indexterm zone="gss-add-oid-set-member"><primary>gss_add_oid_set_member</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_add_oid_set_member              (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> member_oid</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *oid_set</parameter>);</programlisting>
<para>
Add an Object Identifier to an Object Identifier set.  This routine
is intended for use in conjunction with gss_create_empty_oid_set
when constructing a set of mechanism OIDs for input to
gss_acquire_cred.  The oid_set parameter must refer to an OID-set
that was created by GSS-API (e.g. a set returned by
<link linkend="gss-create-empty-oid-set"><function>gss_create_empty_oid_set()</function></link>). GSS-API creates a copy of the
member_oid and inserts this copy into the set, expanding the
storage allocated to the OID-set's elements array if necessary.
The routine may add the new member OID anywhere within the elements
array, and implementations should verify that the new member_oid is
not already contained within the elements array; if the member_oid
is already present, the oid_set should remain unchanged.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>member_oid</parameter>&#160;:</term>
<listitem><simpara>(Object ID, read) The object identifier to copied into
  the set.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>oid_set</parameter>&#160;:</term>
<listitem><simpara>(Set of Object ID, modify) The set in which the object
  identifier should be inserted.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-test-oid-set-member" role="function">
<title>gss_test_oid_set_member ()</title>
<indexterm zone="gss-test-oid-set-member"><primary>gss_test_oid_set_member</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_test_oid_set_member             (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> member</parameter>,
                                                         <parameter>const <link linkend="gss-OID-set"><type>gss_OID_set</type></link> set</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *present</parameter>);</programlisting>
<para>
Interrogate an Object Identifier set to determine whether a
specified Object Identifier is a member.  This routine is intended
to be used with OID sets returned by <link linkend="gss-indicate-mechs"><function>gss_indicate_mechs()</function></link>,
<link linkend="gss-acquire-cred"><function>gss_acquire_cred()</function></link>, and <link linkend="gss-inquire-cred"><function>gss_inquire_cred()</function></link>, but will also work with
user-generated sets.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>member</parameter>&#160;:</term>
<listitem><simpara>(Object ID, read) The object identifier whose presence is
  to be tested.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>set</parameter>&#160;:</term>
<listitem><simpara>(Set of Object ID, read) The Object Identifier set.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>present</parameter>&#160;:</term>
<listitem><simpara>(Boolean, modify) Non-zero if the specified OID is a
  member of the set, zero if not.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-inquire-names-for-mech" role="function">
<title>gss_inquire_names_for_mech ()</title>
<indexterm zone="gss-inquire-names-for-mech"><primary>gss_inquire_names_for_mech</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_inquire_names_for_mech          (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> mechanism</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *name_types</parameter>);</programlisting>
<para>
Returns the set of nametypes supported by the specified mechanism.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mechanism</parameter>&#160;:</term>
<listitem><simpara>(gss_OID, read) The mechanism to be interrogated.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>name_types</parameter>&#160;:</term>
<listitem><simpara>(gss_OID_set, modify) Set of name-types supported by
  the specified mechanism.  The returned OID set must be freed by
  the application after use with a call to <link linkend="gss-release-oid-set"><function>gss_release_oid_set()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-inquire-mechs-for-name" role="function">
<title>gss_inquire_mechs_for_name ()</title>
<indexterm zone="gss-inquire-mechs-for-name"><primary>gss_inquire_mechs_for_name</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_inquire_mechs_for_name          (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> input_name</parameter>,
                                                         <parameter><link linkend="gss-OID-set"><type>gss_OID_set</type></link> *mech_types</parameter>);</programlisting>
<para>
Returns the set of mechanisms supported by the GSS-API
implementation that may be able to process the specified name.
</para>
<para>
Each mechanism returned will recognize at least one element within
the name.  It is permissible for this routine to be implemented
within a mechanism-independent GSS-API layer, using the type
information contained within the presented name, and based on
registration information provided by individual mechanism
implementations.  This means that the returned mech_types set may
indicate that a particular mechanism will understand the name when
in fact it would refuse to accept the name as input to
gss_canonicalize_name, gss_init_sec_context, gss_acquire_cred or
gss_add_cred (due to some property of the specific name, as opposed
to the name type).  Thus this routine should be used only as a
prefilter for a call to a subsequent mechanism-specific routine.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>input_name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, read) The name to which the inquiry
  relates.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mech_types</parameter>&#160;:</term>
<listitem><simpara>(gss_OID_set, modify) Set of mechanisms that may
  support the specified name.  The returned OID set must be freed
  by the caller after use with a call to <link linkend="gss-release-oid-set"><function>gss_release_oid_set()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_BAD_NAME`: The input_name parameter was ill-formed.

`GSS_S_BAD_NAMETYPE`: The input_name parameter contained an invalid
or unsupported type of name.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-canonicalize-name" role="function">
<title>gss_canonicalize_name ()</title>
<indexterm zone="gss-canonicalize-name"><primary>gss_canonicalize_name</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_canonicalize_name               (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> input_name</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> mech_type</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *output_name</parameter>);</programlisting>
<para>
Generate a canonical mechanism name (MN) from an arbitrary internal
name.  The mechanism name is the name that would be returned to a
context acceptor on successful authentication of a context where
the initiator used the input_name in a successful call to
gss_acquire_cred, specifying an OID set containing <parameter>mech_type</parameter> as
its only member, followed by a call to <link linkend="gss-init-sec-context"><function>gss_init_sec_context()</function></link>,
specifying <parameter>mech_type</parameter> as the authentication mechanism.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>input_name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, read) The name for which a canonical form
  is desired.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mech_type</parameter>&#160;:</term>
<listitem><simpara>(Object ID, read) The authentication mechanism for
  which the canonical form of the name is desired.  The desired
  mechanism must be specified explicitly; no default is provided.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>output_name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, modify) The resultant canonical name.
  Storage associated with this name must be freed by the
  application after use with a call to <link linkend="gss-release-name"><function>gss_release_name()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-duplicate-name" role="function">
<title>gss_duplicate_name ()</title>
<indexterm zone="gss-duplicate-name"><primary>gss_duplicate_name</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_duplicate_name                  (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-name-t"><type>gss_name_t</type></link> src_name</parameter>,
                                                         <parameter><link linkend="gss-name-t"><type>gss_name_t</type></link> *dest_name</parameter>);</programlisting>
<para>
Create an exact duplicate of the existing internal name <parameter>src_name</parameter>.
The new <parameter>dest_name</parameter> will be independent of src_name (i.e. <parameter>src_name</parameter>
and <parameter>dest_name</parameter> must both be released, and the release of one shall
not affect the validity of the other).</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>src_name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, read) Internal name to be duplicated.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>dest_name</parameter>&#160;:</term>
<listitem><simpara>(gss_name_t, modify) The resultant copy of <parameter>src_name</parameter>.
  Storage associated with this name must be freed by the application
  after use with a call to <link linkend="gss-release-name"><function>gss_release_name()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_BAD_NAME`: The src_name parameter was ill-formed.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-sign" role="function">
<title>gss_sign ()</title>
<indexterm zone="gss-sign"><primary>gss_sign</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_sign                            (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> qop_req</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> message_buffer</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> message_token</parameter>);</programlisting>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>qop_req</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>message_buffer</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>message_token</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-verify" role="function">
<title>gss_verify ()</title>
<indexterm zone="gss-verify"><primary>gss_verify</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_verify                          (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> message_buffer</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> token_buffer</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *qop_state</parameter>);</programlisting>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>message_buffer</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>token_buffer</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>qop_state</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-seal" role="function">
<title>gss_seal ()</title>
<indexterm zone="gss-seal"><primary>gss_seal</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_seal                            (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> conf_req_flag</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> qop_req</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> input_message_buffer</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *conf_state</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> output_message_buffer</parameter>);</programlisting>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>conf_req_flag</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>qop_req</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>input_message_buffer</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>conf_state</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>output_message_buffer</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-unseal" role="function">
<title>gss_unseal ()</title>
<indexterm zone="gss-unseal"><primary>gss_unseal</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_unseal                          (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter><link linkend="gss-ctx-id-t"><type>gss_ctx_id_t</type></link> context_handle</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> input_message_buffer</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> output_message_buffer</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *conf_state</parameter>,
                                                         <parameter><link linkend="int"><type>int</type></link> *qop_state</parameter>);</programlisting>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context_handle</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>input_message_buffer</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>output_message_buffer</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>conf_state</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>qop_state</parameter>&#160;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gss-inquire-saslname-for-mech" role="function" condition="since:0.1.4">
<title>gss_inquire_saslname_for_mech ()</title>
<indexterm zone="gss-inquire-saslname-for-mech" role="0.1.4"><primary>gss_inquire_saslname_for_mech</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_inquire_saslname_for_mech       (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-OID"><type>gss_OID</type></link> desired_mech</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> sasl_mech_name</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> mech_name</parameter>,
                                                         <parameter><link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> mech_description</parameter>);</programlisting>
<para>
Output the SASL mechanism name of a GSS-API mechanism.  It also
returns a name and description of the mechanism in a user friendly
form.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>desired_mech</parameter>&#160;:</term>
<listitem><simpara>(OID, read) Identifies the GSS-API mechanism to query.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>sasl_mech_name</parameter>&#160;:</term>
<listitem><simpara>(buffer, character-string, modify, optional)
  Buffer to receive SASL mechanism name.  The application must free
  storage associated with this name after use with a call to
  <link linkend="gss-release-buffer"><function>gss_release_buffer()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mech_name</parameter>&#160;:</term>
<listitem><simpara>(buffer, character-string, modify, optional) Buffer to
  receive human readable mechanism name.  The application must free
  storage associated with this name after use with a call to
  <link linkend="gss-release-buffer"><function>gss_release_buffer()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mech_description</parameter>&#160;:</term>
<listitem><simpara>(buffer, character-string, modify, optional)
  Buffer to receive description of mechanism.  The application must
  free storage associated with this name after use with a call to
  <link linkend="gss-release-buffer"><function>gss_release_buffer()</function></link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_BAD_MECH`: The <parameter>desired_mech</parameter> OID is unsupported.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.1.4</para></refsect2>
<refsect2 id="gss-inquire-mech-for-saslname" role="function" condition="since:0.1.4">
<title>gss_inquire_mech_for_saslname ()</title>
<indexterm zone="gss-inquire-mech-for-saslname" role="0.1.4"><primary>gss_inquire_mech_for_saslname</primary></indexterm>
<programlisting><link linkend="OM-uint32"><returnvalue>OM_uint32</returnvalue></link>           gss_inquire_mech_for_saslname       (<parameter><link linkend="OM-uint32"><type>OM_uint32</type></link> *minor_status</parameter>,
                                                         <parameter>const <link linkend="gss-buffer-t"><type>gss_buffer_t</type></link> sasl_mech_name</parameter>,
                                                         <parameter><link linkend="gss-OID"><type>gss_OID</type></link> *mech_type</parameter>);</programlisting>
<para>
Output GSS-API mechanism OID of mechanism associated with given
<parameter>sasl_mech_name</parameter>.</para>
<variablelist role="params">
<varlistentry><term><parameter>minor_status</parameter>&#160;:</term>
<listitem><simpara>(Integer, modify) Mechanism specific status code.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>sasl_mech_name</parameter>&#160;:</term>
<listitem><simpara>(buffer, character-string, read) Buffer with SASL
  mechanism name.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mech_type</parameter>&#160;:</term>
<listitem><simpara>(OID, modify, optional) Actual mechanism used.  The OID
  returned via this parameter will be a pointer to static storage
  that should be treated as read-only; In particular the
  application should not attempt to free it.  Specify <link linkend="NULL:CAPS"><literal>NULL</literal></link> if not
  required.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara>

`GSS_S_COMPLETE`: Successful completion.

`GSS_S_BAD_MECH`: There is no GSS-API mechanism known as <parameter>sasl_mech_name</parameter>.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 0.1.4</para></refsect2>

</refsect1>

</refentry>
